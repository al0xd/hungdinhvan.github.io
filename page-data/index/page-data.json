{"componentChunkName":"component---src-templates-index-js","path":"/","result":{"data":{"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__612e07af894d3804d9ca6d95","title":"GraphQL on Rails:\nFrom zero to the first query","slug":"graphql-on-rails-from-zero-to-the-first-query","featured":false,"feature_image":"https://iron.fordeer.agency/content/images/2021/08/cover-41f83d0.png","excerpt":"A hitchhiker’s guide to developing GraphQL applications with Rails on the\nbackend side and React/Apollo on the frontend side. Follow this multi-part\ntutorial to learn both the basics and the advanced topics by example and feel\nthe power of this modern technology.\n\nGraphQL [https://graphql.org/] is one of those new shiny things we’ve been\nseeing here, there and everywhere: blog posts\n[https://dev.to/evilmartians/exposing-permissions-in-graphql-apis-with-action-policy-536a-temp-slug-455298?preview","custom_excerpt":null,"visibility":"public","created_at_pretty":"31 August, 2021","published_at_pretty":"31 August, 2021","updated_at_pretty":"31 August, 2021","created_at":"2021-08-31T17:42:55.000+07:00","published_at":"2021-08-31T17:45:05.000+07:00","updated_at":"2021-08-31T17:45:04.000+07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"IRON","slug":"iron","bio":null,"profile_image":"https://iron.fordeer.agency/content/images/2021/08/T-Banners-Icons-S14-HighTowerTomato-L.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"IRON","slug":"iron","bio":null,"profile_image":"https://iron.fordeer.agency/content/images/2021/08/T-Banners-Icons-S14-HighTowerTomato-L.png","twitter":null,"facebook":null,"website":null},"primary_tag":null,"tags":[],"plaintext":"A hitchhiker’s guide to developing GraphQL applications with Rails on the\nbackend side and React/Apollo on the frontend side. Follow this multi-part\ntutorial to learn both the basics and the advanced topics by example and feel\nthe power of this modern technology.\n\nGraphQL [https://graphql.org/] is one of those new shiny things we’ve been\nseeing here, there and everywhere: blog posts\n[https://dev.to/evilmartians/exposing-permissions-in-graphql-apis-with-action-policy-536a-temp-slug-455298?preview=5921586e85991fd5515f56b0ab8401d5fa1acb757e53ffc9c32c06243664d434f816c731482815c58f8a058def1cc2ae05638aacfce6c09d473010dc]\n, conferences [https://www.graphqlconf.org/], podcasts\n[https://graphqlradio.com/], maybe, even newspapers. It sounds like you should\nhurry up and start rewriting your application in GraphQL instead of REST as soon\nas possible, right? Not exactly. Remember: there is no silver bullet. It’s\nessential to understand the pros and cons of the technology before making a\nparadigm-shift decision.\n\nCheck out Part 2\n[https://evilmartians.com/chronicles/graphql-on-rails-2-updating-the-data] and \nPart 3\n[https://evilmartians.com/chronicles/graphql-on-rails-3-on-the-way-to-perfection]\n\nIn this series, we’re going to walk you through a no-frills guide to the\ndevelopment of GraphQL applications, talking about not only its advantages but\nalso its caveats and pitfalls (and, of course, the ways to deal with them).\n\nGraphQL in a nutshell\nThere are a lot of other query languages, for instance, SQL and XPath.\n\nAccording to the specification [https://graphql.github.io/graphql-spec/],\nGraphQL is a query language and runtime (or execution engine). Query language, \nby definition [https://en.wikipedia.org/wiki/Query_language], describes how to\ncommunicate with an information system. Runtime is responsible for fulfilling\nqueries with data.\n\nAt the core of every GraphQL application lies a schema\n[https://graphql.org/learn/schema/]: it describes the underlying data in the\nform of a directed graph. The runtime must execute queries according to the\nschema (and some general rules from the specification). That means, every valid\nGraphQL server runs queries in the same manner and returns data in the same\nformat for the same schema. In other words, the schema is everything clients\nshould know about the API.\n\nHere is an example of a simple GraphQL query:\n\nquery getProduct($id: Int!) {\n  product(id: $id) {\n    id\n    title\n    manufacturer {\n      name\n    }\n  }\n}\n\n\nLet’s dissect it line by line:\n\n * We define a named query (getProduct is the operation name) accepting a single\n   argument ($id). The operation name is optional, but it helps readability and\n   could be used by frontend for caching.\n * We “select” the product field from the “root” of the schema and pass the $id \n   value as an argument.\n * We describe the fields we want to fetch: in this case, we want to get the id \n   and title of the product as well as the name of the manufacturer.\n\n> Essentially, a query represents a sub-graph of the schema, which brings the\nfirst benefit of GraphQL—we can fetch only this data we need and all we need at\nonce, in a single query.\nCheck out this Stack Overflow post\n[https://stackoverflow.com/questions/44564905/what-is-over-fetching-or-under-fetching] \nto learn more about both overfetching and underfetching.\n\nThis way, we solve one of the common problems of the traditional REST APIs—\noverfetching.\n\nAnother noticeable feature of GraphQL schemas is they are strongly typed: both\nclient and runtime ensure that the data passed is valid from the perspective of\nthe application’s type system. For example, if someone mistakenly passes a\nstring value as the $id to the query above, the client fails with the exception\nwithout even trying to perform a request.\n\nThere are plenty of tools to convert a schema into an interactive documentation\nwebsite, standalone (e.g., GraphiQL [https://github.com/graphql/graphiql] or \ngraphdoc [https://2fd.github.io/graphdoc]) and framework-specific (e.g., Apollo\nDevTools\n[https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm]\n).\n\nAnd the last but not least bonus is a schema introspection: clients can learn\nthe API from the schema itself, without any additional documentation sources.\n\nWe’ve just learned a bunch of theoretical aspects of GraphQL. Now it’s time to\ndo some coding exercises to make sure you won’t forget everything tomorrow’s\nmorning.\n\nWhat are we going to build?\nDuring this series, we will be building an application representing a “Martian\nLibrary”—a personal online collection of movies, books, and other art objects\nrelated to the Red Planet.\n\nThe application we are going to build\n\nFor this tutorial, we’re going to use:\n\n * Ruby 2.6 and Rails 6 (release candidate is already here\n   [https://evilmartians.com/chronicles/rails-6-b-sides-and-rarities]) for\n   backend.\n * Node.js 9+, React 16.3+, and Apollo (client version 2+) for frontend (and\n   make sure you have yarn installed according to the instruction\n   [https://yarnpkg.com/en/docs/install#mac-stable]).\n\nYou can find the source code here\n[https://github.com/evilmartians/chronicles-gql-martian-library/tree/part-1]\n—don’t forget to run bundle install && yarn install before the first run. Master\n[https://github.com/evilmartians/chronicles-gql-martian-library] represents a\ncurrent state of the project.\n\nSetting up a new Rails project\nIf at the time of reading this article Rails 6.0 hasn’t been released yet, you\nmight need to install the release candidate first:\n\n$ gem install rails --pre\n$ rails -v\n=> Rails 6.0.0.rc1\n\n\nNow we’re ready to run this unexpectedly long rails new command:\n\n$ rails new martian-library -d postgresql --skip-action-mailbox --skip-action-text --skip-spring --webpack=react -T --skip-turbolinks\n\n\nWe prefer okonomi to omakase [https://dhh.dk/2012/rails-is-omakase.html]: skip\nframeworks and libraries we don’t need, choose PostgreSQL as our database,\npreconfigure Webpacker to use React, and skip tests (don’t worry–we’ll add RSpec\nsoon).\n\nBefore you start, it’s strongly recommended that you disable all the unnecessary\ngenerators in theconfig/application.rb:\n\nconfig.generators do |g|\n  g.test_framework  false\n  g.stylesheets     false\n  g.javascripts     false\n  g.helper          false\n  g.channel         assets: false\nend\n\n\nPreparing the data model\nWe need at least two models to start:\n\n * Item to describe any entity (book, movie, etc.) that we want to store in the\n   library\n * User to represent the application user who can manage items in the\n   collection.\n\nLet’s generate them:\n\n$ rails g model User first_name last_name email\n$ rails g model Item title description:text image_url user:references\n\n\nDon’t forget to add the has_many :items association to app/models/user.rb:\n\n# app/models/user.rb\nclass User < ApplicationRecord\n  has_many :items, dependent: :destroy\nend\n\n\nLet’s add some pre-generated data to db/seeds.rb:\n\n# db/seeds.rb\njohn = User.create!(\n  email: \"john.doe@example.com\",\n  first_name: \"John\",\n  last_name: \"Doe\"\n)\n\njane = User.create!(\n  email: \"jane.doe@example.com\",\n  first_name: \"Jane\",\n  last_name: \"Doe\"\n)\n\nItem.create!(\n  [\n    {\n      title: \"Martian Chronicles\",\n      description: \"Cult book by Ray Bradbury\",\n      user: john,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/4/45/The-Martian-Chronicles.jpg\"\n    },\n    {\n      title: \"The Martian\",\n      description: \"Novel by Andy Weir about an astronaut stranded on Mars trying to survive\",\n      user: john,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/c/c3/The_Martian_2014.jpg\"\n    },\n    {\n      title: \"Doom\",\n      description: \"A group of Marines is sent to the red planet via an ancient \" \\\n                   \"Martian portal called the Ark to deal with an outbreak of a mutagenic virus\",\n      user: jane,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/5/57/Doom_cover_art.jpg\"\n    },\n    {\n      title: \"Mars Attacks!\",\n      description: \"Earth is invaded by Martians with unbeatable weapons and a cruel sense of humor\",\n      user: jane,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/b/bd/Mars_attacks_ver1.jpg\"\n    }\n  ]\n)\n\n\nFinally, we’re ready to initialize our database:\n\n$ rails db:create db:migrate db:seed\n\n\nNow that we’ve put some information into our system, let’s add a way to access\nit!\n\nAdding a GraphQL endpoint\nFor crafting our GraphQL API, we will use the graphql-ruby\n[https://github.com/rmosolgo/graphql-ruby] gem:\n\n# First, add it to the Gemfile\n$ bundle add graphql --version=\"~> 1.9\"\n# Then, run the generator\n$ rails generate graphql:install\n\n\nYou might be surprised by the number of files a minimal graphql-ruby application\nrequires: this boilerplate is the price we pay for all the goodies we described\nabove.\n\nThe result of executing graphql:install generator\n\nFirst of all, let’s take a look at the schema, martian_library_schema.rb:\n\n# app/graphql/martian_library_schema.rb\nclass MartianLibrarySchema < GraphQL::Schema\n  query(Types::QueryType)\n  mutation(Types::MutationType)\nend\n\n\nThe schema declares that all the queries should go to Types::QueryType while\nmutations should go to Types::MutationType. We’re going to dig deeper into\nmutations in the second part of the series; the goal of this article is to learn\nhow to write and execute queries. Thus, let’s open the types/query_type.rb \nclass—it is an entry point for all the queries. What’s inside?\n\n# app/graphql/types/query_type.rb\nmodule Types\n  class QueryType < Types::BaseObject\n    # Add root-level fields here.\n    # They will be entry points for queries on your schema.\n\n    # TODO: remove me\n    field :test_field, String, null: false,\n      description: \"An example field added by the generator\"\n    def test_field\n      \"Hello World!\"\n    end\n  end\nend\n\n\nIt turns out that QueryType is just a regular type: it inherits from the \nTypes::BaseObject (which we will use as a base class for all types), and it has \nfield definitions–the nodes of our data graph. The only thing that makes \nQueryType different is that GraphQL requires this type to exist (while mutation \nand subscription types are optional).\n\nHave noticed that the code above is actually a “hello world” app? Before going\nfurther (and boring you with by the amount of code), we’d like to show you how\nto get this “hello world” in your browser.\n\nLet’s see what has been added to the config/routes.rb file by the generator:\n\n# config/routes.rb\nRails.application.routes.draw do\n  mount GraphiQL::Rails::Engine, at: \"/graphiql\", graphql_path: \"/graphql\" if Rails.env.development?\n  post \"/graphql\", to: \"graphql#execute\"\nend\n\n\nMounting GraphiQL::Rails::Engine allows us to test our queries and mutations\nusing a web interface called GraphiQL [https://github.com/graphql/graphiql]. As\nwe discussed in the introduction, the schema can be inspected, and GraphiQL uses\nthis feature to build interactive documentation for us. It’s time to give it a\nshot!\n\n# Let's run a Rails web server\n$ rails s\n\n\nOpen up http://localhost:3000/graphiql in the browser:\n\nGraphiQL UI\n\nIn the left pane, you can type a query to execute, then click the “play” button\n(or hit Ctrl/Cmd+Enter) and get the response in the right pane. By clicking the\n“Docs” link at the right top corner, you can explore your schema.\n\nLet’s take a look at our logs—we want to know what happens when we click the\nexecute button.\n\nExecution logs\n\nGraphQL is transport-agnostic, but most implementations, including ruby-graphql,\nuse HTTP POST requests.\n\nRequests are sent to GraphqlController, which has also been added to the\napplication by the graphql gem generator.\n\nTake a look at the GraphqlController#execute action:\n\n# app/controllers/graphql_controller.rb\ndef execute\n  variables = ensure_hash(params[:variables])\n  query = params[:query]\n  operation_name = params[:operationName]\n  context = {\n    # Query context goes here, for example:\n    # current_user: current_user,\n  }\n  result = GraphqlSchema.execute(\n    query,\n    variables: variables,\n    context: context,\n    operation_name: operation_name\n  )\n  render json: result\nrescue StandardError => e\n  raise e unless Rails.env.development?\n\n  handle_error_in_development e\nend\n\n\nThis action calls the GraphqlSchema#execute method with the following\nparameters:\n\n * query and variables represent a query string and arguments sent by a client\n   respectively;\n * context is an arbitrary hash, which will be available during the query\n   execution everywhere;\n * operation_name picks a named operation from the incoming request to execute\n   (could be empty).\n\nAll the magic happens inside this method: it parses the query, detects all the\ntypes that should be used for building the response, and resolves all the\nrequested fields. The only thing we need to do is to define the types and\ndeclare how fields should be resolved.\n\nWhat’s in the Martian Library?\nLet’s move from “hello world” to something real: remove the example contents\nfrom Types::QueryType and register a field called :items which will return all\nthe items from the library. We also need to add a resolver method for this field\n(the resolver method name must match the field name):\n\n# app/graphql/types/query_type.rb\nmodule Types\n  class QueryType < Types::BaseObject\n    field :items,\n          [Types::ItemType],\n          null: false,\n          description: \"Returns a list of items in the martian library\"\n\n    def items\n      Item.all\n    end\n  end\nend\n\n\nEach field definition contains a name, a result type, and options; :null is\nrequired and must be set to either true or false. We also define optional \n:description—it’s a good practice to add a human-readable message to a field: it\nwill be automatically added to documentation providing more context to\ndevelopers. The array notation for the result type, [Types::ItemType], means\nthat the field value must be an array and each element of this array must be\nrepresented using the Types::ItemType type.\n\nBut we haven’t defined ItemType yet, right? Hopefully, the graphql gem will give\nus a handy generator:\n\n$ rails g graphql:object item\n\n\nNow we can modify the newly created app/graphql/types/item_type.rb to our\nliking.\n\n# app/graphql/types/item_type.rb\nmodule Types\n  class ItemType < Types::BaseObject\n    field :id, ID, null: false\n    field :title, String, null: false\n    field :description, String, null: true\n    field :image_url, String, null: true\n  end\nend\n\n\nYou may use UUID as a primary key in your table if you are worried about\nexposing sequential IDs, but let’s go with the easy way now.\n\nAs you can see, we’re exposing three fields in ItemType:\n\n * non-nullable fields id and title\n * a nullable field description\n\nOur execution engine resolves fields using the following algorithm (slightly\nsimplified):\n\n * First, it looks for the method with the same name defined in the type class\n   itself (like we did earlier in the QueryType for items); we can access the\n   object being resolved using the object method.\n * If no such method defined, it tries to call the method with the same name on\n   the object itself.\n\nWe do not define any methods in our type class; thus, we assume that the\nunderlying implements all the fields’ methods.\n\nGo back to http://localhost:3000/graphiql, execute the following query, and make\nsure that you get the list of all items in response:\n\n{\n  items {\n    id\n    title\n    description\n  }\n}\n\n\nSo far, we haven’t added any functionality that leverages the power of\ngraphs—our current graph’s depth is one. Let’s grow the graph by adding a\nnon-primitive node to ItemType, for example, a user field to represent the user\nwho created the item:\n\n# app/graphql/types/item_type.rb\nmodule Types\n  class ItemType < Types::BaseObject\n    # ...\n    field :user, Types::UserType, null: false\n  end\nend\n\n\nLet’s repeat the same generator spell to create a new type class:\n\n$ rails g graphql:object user\n\n\nThis time we also want to add a computed field—full_name:\n\n# app/graphql/types/user_type.rb\nmodule Types\n  class UserType < Types::BaseObject\n    field :id, ID, null: false\n    field :email, String, null: false\n    field :full_name, String, null: false\n\n    def full_name\n      # `object` references the user instance\n      [object.first_name, object.last_name].compact.join(\" \")\n    end\n  end\nend\n\n\nLet’s transform our query to fetch users along with items:\n\n{\n  items {\n    id\n    title\n    user {\n      id\n      email\n    }\n  }\n}\n\n\nAt this point, we’re ready to move our attention from the backend side to the\nfrontend side. Let’s build a client for this API!\n\nConfiguring the frontend application\nIf you’re using Google Chrome, mind installing the Apollo extension\n[https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm]\n.\n\nAs we already mentioned, we recommend you install the Apollo\n[https://www.apollographql.com/docs/react/] framework for dealing with GraphQL\nclient-side.\n\nTo get the ball rolling, we need to install all the required dependencies:\n\n$ yarn add apollo-client apollo-cache-inmemory apollo-link-http apollo-link-error apollo-link graphql graphql-tag react-apollo\n\n\nWe didn’t include any package-adding types to JS (TypeScript\n[http://www.typescriptlang.org/] or Flow [https://flow.org/]) so as not to make\nthis tutorial too complicated. In practice, using typed JS with GraphQL makes a\nlot of sense since we already have a types system. For instance, apollo-codegen\n[https://github.com/apollographql/apollo-tooling] can generate type signatures\nautomatically.\n\nLet’s take a look at some of the installed packages:\n\n * We use graphql-tag to build our first queries.\n * apollo-client is a generic framework-agnostic package for performing and\n   caching GraphQL requests.\n * apollo-cache-inmemory is a storage implementation for Apollo cache.\n * react-apollo contains a set of React components for displaying data.\n * apollo-link and other links implement a middleware pattern for apollo-client \n   operations (you can find further details here\n   [https://www.apollographql.com/docs/link/overview.html]).\n\nNow we need to create an entry point for our frontend application. Remove \nhello_react.jsx from the packs folder and add index.js:\n\n$ rm app/javascript/packs/hello_react.jsx && touch app/javascript/packs/index.js\n\n\nFor the sake of debugging, it’s good enough to stay with the following content:\n\n// app/javascript/packs/index.js\nconsole.log('👻');\n\n\nLet’s generate a controller to serve our frontend application:\n\n$ rails g controller Library index --skip-routes\n\n\nUpdate app/views/library/index.html.erb to contain the React root element and a\nlink to our pack:\n\n<!-- app/views/library/index.html.erb -->\n<div id=\"root\" />\n<%= javascript_pack_tag 'index' %>\n\n\nFinally, let’s register a new route in the config/routes.rb:\n\n# config/routes.rb\nroot 'library#index'\n\n\nRestart your Rails server and make sure you see the ghost in the browser\nconsole. Don’t be scared.\n\nConfiguring Apollo\nCreate a file for storing our application’s Apollo config:\n\n$ mkdir -p app/javascript/utils && touch app/javascript/utils/apollo.js\n\n\nIn this file we want to configure the two core entities of the Apollo\napplication, the client and the cache (or more precisely, the functions to\ncreate both):\n\n// app/javascript/utils/apollo.js\n\n// client\nimport { ApolloClient } from 'apollo-client';\n// cache\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n// links\nimport { HttpLink } from 'apollo-link-http';\nimport { onError } from 'apollo-link-error';\nimport { ApolloLink, Observable } from 'apollo-link';\nexport const createCache = () => {\n  const cache = new InMemoryCache();\n  if (process.env.NODE_ENV === 'development') {\n    window.secretVariableToStoreCache = cache;\n  }\n  return cache;\n};\n\n\nCaching is one of the most powerful features of Apollo. Sometimes it becomes\noverpowering, and you might prefer a more straightforward solution. In any case,\nit’s worth learning how it works. Find more details about how Apollo caching\nworks here [https://www.apollographql.com/docs/react/advanced/caching.html].\n\nLet’s take a second and look at how cache works.\n\nEach query response is put into the cache (the corresponding request is used to\ngenerate the cache key). Before making a request, apollo-client ensures that the\nresponse hasn’t been cached yet, and if it has been–the request is not\nperformed. This behavior is configurable: for instance, we can turn off caching\nfor a particular request or ask the client to look for a cache entry of a\ndifferent query.\n\nOne important thing we need to know about the cache mechanism for this tutorial\nis that, by default, a cache key is a concatenation of the object id and \n__typename. Thus, fetching the same object twice would result only in one\nrequest.\n\nBack to coding. Since we use HTTP POST as a transport, we need to attach a\nproper CSRF token to every request to pass the forgery protection check\n[https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf] \nin the Rails app. We can grab it from meta[name=\"csrf-token\"] (which is\ngenerated by <%= csrf_meta_tags %>):\n\n// app/javascript/utils/apollo.js\n// ...\n// getToken from meta tags\nconst getToken = () =>\n  document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content');\nconst token = getToken();\nconst setTokenForOperation = async operation =>\n  operation.setContext({\n    headers: {\n      'X-CSRF-Token': token,\n    },\n  });\n// link with token\nconst createLinkWithToken = () =>\n  new ApolloLink(\n    (operation, forward) =>\n      new Observable(observer => {\n        let handle;\n        Promise.resolve(operation)\n          .then(setTokenForOperation)\n          .then(() => {\n            handle = forward(operation).subscribe({\n              next: observer.next.bind(observer),\n              error: observer.error.bind(observer),\n              complete: observer.complete.bind(observer),\n            });\n          })\n          .catch(observer.error.bind(observer));\n        return () => {\n          if (handle) handle.unsubscribe();\n        };\n      })\n  );\n\n\nLet’s look at how we can log errors:\n\n// app/javascript/utils/apollo.js\n//...\n// log erors\nconst logError = (error) => console.error(error);\n// create error link\nconst createErrorLink = () => onError(({ graphQLErrors, networkError, operation }) => {\n  if (graphQLErrors) {\n    logError('GraphQL - Error', {\n      errors: graphQLErrors,\n      operationName: operation.operationName,\n      variables: operation.variables,\n    });\n  }\n  if (networkError) {\n    logError('GraphQL - NetworkError', networkError);\n  }\n})\n\n\nIn production, it makes more sense to use an exception tracking service (e.g.,\nSentry or Honeybadger): just override the logError function to send errors to\nthe external system.\n\nWe’re almost there—let’s tell the client about the endpoint for making queries:\n\n// app/javascript/utils/apollo.js\n//...\n// http link\nconst createHttpLink = () => new HttpLink({\n  uri: '/graphql',\n  credentials: 'include',\n})\n\n\nFinally, we’re ready to create an Apollo client instance:\n\n// app/javascript/utils/apollo.js\n//...\nexport const createClient = (cache, requestLink) => {\n  return new ApolloClient({\n    link: ApolloLink.from([\n      createErrorLink(),\n      createLinkWithToken(),\n      createHttpLink(),\n    ]),\n    cache,\n  });\n};\n\n\nThe very first query\nWe’re going to use a provider pattern\n[https://reactjs.org/docs/context.html#contextprovider] to pass the client\ninstances to React components:\n\n$ mkdir -p app/javascript/components/Provider && touch app/javascript/components/Provider/index.js\n\n\nIt’s the first time we are using an ApolloProvider component from the \nreact-apollo library:\n\n// app/javascript/components/Provider/index.js\nimport React from 'react';\nimport { ApolloProvider } from 'react-apollo';\nimport { createCache, createClient } from '../../utils/apollo';\n\nexport default ({ children }) => (\n  <ApolloProvider client={createClient(createCache())}>\n    {children}\n  </ApolloProvider>\n);\n\n\nLet’s change our index.js to use the newly created provider:\n\n// app/javascript/packs/index.js\nimport React from 'react';\nimport { render } from 'react-dom';\nimport Provider from '../components/Provider';\n\nrender(<Provider>👻</Provider>, document.querySelector('#root'));\n\n\nIf you use Webpacker v3 you may need to import babel-polyfill to use all the\ncool JavaScript tricks like async/await. Don’t worry about the polyfill’s size; \nbabel-preset-env will remove everything you don’t need.\n\nLet’s create a Library component to display the list of items on the page:\n\n$ mkdir -p app/javascript/components/Library && touch app/javascript/components/Library/index.js\n\n\nWe’re going to use the Query component from react-apollo, which accepts the \nquery string as a property to fetch the data on mount:\n\n// app/javascript/components/Library/index.js\nimport React from 'react';\nimport { Query } from 'react-apollo';\nimport gql from 'graphql-tag';\n\nconst LibraryQuery = gql`\n  {\n    items {\n      id\n      title\n      user {\n        email\n      }\n    }\n  }\n`;\n\nexport default () => (\n  <Query query={LibraryQuery}>\n    {({ data, loading }) => (\n      <div>\n        {loading\n          ? 'loading...'\n          : data.items.map(({ title, id, user }) => (\n              <div key={id}>\n                <b>{title}</b> {user ? `added by ${user.email}` : null}\n              </div>\n            ))}\n      </div>\n    )}\n  </Query>\n);\n\n\nWe can access the loading state and loaded data through the corresponding \nloading and data properties (passed using a so-called render-props pattern\n[https://reactjs.org/docs/render-props.html]).\n\nDon’t forget to add the component to the main page:\n\n// app/javascript/packs/index.js\nimport React from 'react';\nimport { render } from 'react-dom';\nimport Provider from '../components/Provider';\nimport Library from '../components/Library';\n\nrender(\n  <Provider>\n    <Library />\n  </Provider>,\n  document.querySelector('#root')\n);\n\n\nIf you reload the page you should see the list of items with emails of users who\nadded them:\n\nList of items with emails of users\n\nCongratulations! You’ve just made the very first step towards GraphQL happiness!\n\n…And the very first problem\nEverything seems to work fine, but let’s take a look at our server logs:\n\nN + 1\n\nThe SQL query SELECT * FROM users WHERE id = ? is executed four times, which\nmeans that we hit the famous N+1 problem–server makes a query for each item in\nthe collection to get the corresponding user info.\n\nBefore fixing the problem, we need to make sure that it’s safe to make code\nmodifications without breaking anything—let’s write some tests!\n\nWriting some specs\nSince we’re running on the edge, we need the upcoming version of the gem.\n\nNow it’s time to install and configure RSpec, or more precisely, the rspec-rails \ngem:\n\n# Add gem to the Gemfile\n$ bundle add rspec-rails --version=\"4.0.0.beta2\" --group=\"development,test\"\n# Generate the initial configuration\n$ rails generate rspec:install\n\n\nTo make it easier to generate data for tests let’s install factory_bot\n[https://github.com/thoughtbot/factory_bot]:\n\n$ bundle add factory_bot_rails --version=\"~> 5.0\" --group=\"development,test\"\n\n\nMake factory methods (create, build, etc.) globally visible in tests by adding \nconfig.include FactoryBot::Syntax::Methods to the rails_helper.rb.\n\nSince we created our models before adding Factory Bot, we should generate our\nfactories manually. Let’s create a single file, spec/factories.rb, for that:\n\n# spec/factories.rb\nFactoryBot.define do\n  factory :user do\n    # Use sequence to make sure that the value is unique\n    sequence(:email) { |n| \"user-#{n}@example.com\" }\n  end\n\n  factory :item do\n    sequence(:title) { |n| \"item-#{n}\" }\n    user\n  end\nend\n\n\nNow we are ready to write our first test. Let’s create a spec file for QueryType\n:\n\n$ mkdir -p spec/graphql/types\n$ touch spec/graphql/types/query_type_spec.rb\n\n\nThe simplest query test looks like this:\n\n# spec/graphql/types/query_type_spec.rb\nrequire \"rails_helper\"\n\nRSpec.describe Types::QueryType do\n  describe \"items\" do\n    let!(:items) { create_pair(:item) }\n\n    let(:query) do\n      %(query {\n        items {\n          title\n        }\n      })\n    end\n\n    subject(:result) do\n      MartianLibrarySchema.execute(query).as_json\n    end\n\n    it \"returns all items\" do\n      expect(result.dig(\"data\", \"items\")).to match_array(\n        items.map { |item| { \"title\" => item.title } }\n      )\n    end\n  end\nend\n\n\nTesting GraphQL might feel repetitive. Should it happen to you—consider using\nfixtures and the fixturama [https://github.com/nepalez/fixturama] gem.\n\nFirst, we create a pair of items in our database. Then, we define the query\nunder test and the subject (result) by calling the GraphqlSchema.execute method.\nRemember, we had a similar line in the GraphqlController#execute?\n\nThis example is very straightforward: we’re not passing either variables or \ncontext to the execute call, though we definitely can do that if needed.\n\nNow we’re confident enough to fix “the bug”—the N+1 problem!\n\nGraphQL vs. N+1 problem\nThe easiest way to avoid N+1 queries is to use eager loading\n[https://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations]\n. In our case, we need to preload users when making a query to fetch items in \nQueryType:\n\n# /app/graphql/types/query_type.rb\nmodule Types\n  class QueryType < Types::BaseObject\n    # ...\n\n    def items\n      Item.preload(:user)\n    end\n  end\nend\n\n\nThis solution can help in simple situations, but it’s not very efficient: the\nfollowing code preloads users even if the client does not need them, e.g.:\n\nitems {\n  title\n}\n\n\nLearn how to solve the N+1 problem using batch loading by example from the \n“Active Storage meets GraphQL”\n[https://dev.to/evilmartians/active-storage-meets-graphql-pt-2-exposing-attachment-urls-2mdn] \npost in our dev.to blog.\n\nDiscussing other ways to solve the N+1 problem is worthy of a dedicated post and\nout of this tutorial’s scope.\nMost of the solutions fit the following two groups:\n\n * lazy eager loading (e.g., using the ar_lazy_preload\n   [https://github.com/DmitryTsepelev/ar_lazy_preload] gem)\n * batch loading (e.g., using the graphql-batch\n   [https://github.com/Shopify/graphql-batch] gem)\n\n\n--------------------------------------------------------------------------------\n\nThat’s all for today! We learned a lot about GraphQL, completed all the routine\nwork of configuring the backend and frontend applications, made the first query,\nand even found and fixed the first bug. And that’s just a tiny step (despite the\nsize of the article) in our journey. We’ll come back shortly and unveil how to\nmanipulate data using GraphQL mutations and keep it up-to-date with\nsubscriptions. Stay tuned!","html":"<p>A hitchhiker’s guide to developing GraphQL applications with Rails on the backend side and React/Apollo on the frontend side. Follow this multi-part tutorial to learn both the basics and the advanced topics by example and feel the power of this modern technology.</p><p><a href=\"https://graphql.org/\">GraphQL</a> is one of those new shiny things we’ve been seeing here, there and everywhere: <a href=\"https://dev.to/evilmartians/exposing-permissions-in-graphql-apis-with-action-policy-536a-temp-slug-455298?preview=5921586e85991fd5515f56b0ab8401d5fa1acb757e53ffc9c32c06243664d434f816c731482815c58f8a058def1cc2ae05638aacfce6c09d473010dc\">blog posts</a>, <a href=\"https://www.graphqlconf.org/\">conferences</a>, <a href=\"https://graphqlradio.com/\">podcasts</a>, maybe, even newspapers. It sounds like you should hurry up and start rewriting your application in GraphQL instead of REST as soon as possible, right? Not exactly. Remember: there is no silver bullet. It’s essential to understand the pros and cons of the technology before making a paradigm-shift decision.</p><p>Check out <a href=\"https://evilmartians.com/chronicles/graphql-on-rails-2-updating-the-data\">Part 2</a> and <a href=\"https://evilmartians.com/chronicles/graphql-on-rails-3-on-the-way-to-perfection\">Part 3</a></p><p>In this series, we’re going to walk you through a no-frills guide to the development of GraphQL applications, talking about not only its advantages but also its caveats and pitfalls (and, of course, the ways to deal with them).</p><h2 id=\"graphql-in-a-nutshell\">GraphQL in a nutshell</h2><p>There are a lot of other query languages, for instance, SQL and XPath.</p><p>According to the <a href=\"https://graphql.github.io/graphql-spec/\">specification</a>, GraphQL is a <em>query language</em> and <em>runtime</em> (or <em>execution engine</em>). Query language, <a href=\"https://en.wikipedia.org/wiki/Query_language\">by definition</a>, describes how to communicate with an information system. Runtime is responsible for fulfilling queries with data.</p><p>At the core of every GraphQL application lies a <a href=\"https://graphql.org/learn/schema/\"><em>schema</em></a>: it describes the underlying data in the form of a directed graph. The runtime must execute queries according to the schema (and some general rules from the specification). That means, every valid GraphQL server runs queries in the same manner and returns data in the same format for the same schema. In other words, the schema is everything clients should know about the API.</p><p>Here is an example of a simple GraphQL query:</p><pre><code>query getProduct($id: Int!) {\n  product(id: $id) {\n    id\n    title\n    manufacturer {\n      name\n    }\n  }\n}\n</code></pre><p>Let’s dissect it line by line:</p><ul><li>We define a named query (<code>getProduct</code> is the operation name) accepting a single argument (<code>$id</code>). The operation name is optional, but it helps readability and could be used by frontend for caching.</li><li>We “select” the <code>product</code> field from the “root” of the schema and pass the <code>$id</code> value as an argument.</li><li>We describe the fields we want to fetch: in this case, we want to get the <code>id</code> and <code>title</code> of the product as well as the <code>name</code> of the manufacturer.</li></ul><blockquote>Essentially, a query represents a sub-graph of the schema, which brings the first benefit of GraphQL—we can fetch only this data we need and all we need at once, in a single query.</blockquote><p>Check out <a href=\"https://stackoverflow.com/questions/44564905/what-is-over-fetching-or-under-fetching\">this Stack Overflow post</a> to learn more about both overfetching and underfetching.</p><p>This way, we solve one of the common problems of the traditional REST APIs—<em>overfetching</em>.</p><p>Another noticeable feature of GraphQL schemas is they are <em>strongly</em> <em>typed</em>: both client and runtime ensure that the data passed is valid from the perspective of the application’s type system. For example, if someone mistakenly passes a string value as the <code>$id</code> to the query above, the client fails with the exception without even trying to perform a request.</p><p>There are plenty of tools to convert a schema into an interactive documentation website, standalone (e.g., <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a> or <a href=\"https://2fd.github.io/graphdoc\">graphdoc</a>) and framework-specific (e.g., <a href=\"https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\">Apollo DevTools</a>).</p><p>And the last but not least bonus is a <em>schema</em> <em>introspection</em>: clients can learn the API from the schema itself, without any additional documentation sources.</p><p>We’ve just learned a bunch of theoretical aspects of GraphQL. Now it’s time to do some coding exercises to make sure you won’t forget everything tomorrow’s morning.</p><h2 id=\"what-are-we-going-to-build\">What are we going to build?</h2><p>During this series, we will be building an application representing a “Martian Library”—a personal online collection of movies, books, and other art objects related to the Red Planet.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://iron.fordeer.agency/content/images/2021/08/application-32576ed.png\" class=\"kg-image\" alt=\"The application we are going to build\" loading=\"lazy\" width=\"1600\" height=\"713\" srcset=\"https://iron.fordeer.agency/content/images/size/w600/2021/08/application-32576ed.png 600w, https://iron.fordeer.agency/content/images/size/w1000/2021/08/application-32576ed.png 1000w, https://iron.fordeer.agency/content/images/2021/08/application-32576ed.png 1600w\" sizes=\"(min-width: 720px) 720px\"><figcaption><p style=\"margin: 0px;\">The application we are going to&nbsp;build</p></figcaption></figure><p>For this tutorial, we’re going to use:</p><ul><li>Ruby 2.6 and Rails 6 (<a href=\"https://evilmartians.com/chronicles/rails-6-b-sides-and-rarities\">release candidate is already here</a>) for backend.</li><li>Node.js 9+, React 16.3+, and Apollo (client version 2+) for frontend (and make sure you have yarn installed according to the <a href=\"https://yarnpkg.com/en/docs/install#mac-stable\">instruction</a>).</li></ul><p>You can find the source code <a href=\"https://github.com/evilmartians/chronicles-gql-martian-library/tree/part-1\">here</a>—don’t forget to run <code>bundle install &amp;&amp; yarn install</code> before the first run. <a href=\"https://github.com/evilmartians/chronicles-gql-martian-library\">Master</a> represents a current state of the project.</p><h2 id=\"setting-up-a-new-rails-project\">Setting up a new Rails project</h2><p>If at the time of reading this article Rails 6.0 hasn’t been released yet, you might need to install the release candidate first:</p><pre><code>$ gem install rails --pre\n$ rails -v\n=&gt; Rails 6.0.0.rc1\n</code></pre><p>Now we’re ready to run this unexpectedly long <code>rails new</code> command:</p><pre><code>$ rails new martian-library -d postgresql --skip-action-mailbox --skip-action-text --skip-spring --webpack=react -T --skip-turbolinks\n</code></pre><p>We prefer <em>okonomi</em> to <a href=\"https://dhh.dk/2012/rails-is-omakase.html\"><em>omakase</em></a>: skip frameworks and libraries we don’t need, choose PostgreSQL as our database, preconfigure Webpacker to use React, and skip tests (don’t worry–we’ll add RSpec soon).</p><p>Before you start, it’s strongly recommended that you disable all the unnecessary generators in the  <code>config/application.rb</code>:</p><pre><code>config.generators do |g|\n  g.test_framework  false\n  g.stylesheets     false\n  g.javascripts     false\n  g.helper          false\n  g.channel         assets: false\nend\n</code></pre><h2 id=\"preparing-the-data-model\">Preparing the data model</h2><p>We need at least two models to start:</p><ul><li><code>Item</code> to describe any entity (book, movie, etc.) that we want to store in the library</li><li><code>User</code> to represent the application user who can manage items in the collection.</li></ul><p>Let’s generate them:</p><pre><code>$ rails g model User first_name last_name email\n$ rails g model Item title description:text image_url user:references\n</code></pre><p>Don’t forget to add the <code>has_many :items</code> association to <code>app/models/user.rb</code>:</p><pre><code># app/models/user.rb\nclass User &lt; ApplicationRecord\n  has_many :items, dependent: :destroy\nend\n</code></pre><p>Let’s add some pre-generated data to <code>db/seeds.rb</code>:</p><pre><code># db/seeds.rb\njohn = User.create!(\n  email: \"john.doe@example.com\",\n  first_name: \"John\",\n  last_name: \"Doe\"\n)\n\njane = User.create!(\n  email: \"jane.doe@example.com\",\n  first_name: \"Jane\",\n  last_name: \"Doe\"\n)\n\nItem.create!(\n  [\n    {\n      title: \"Martian Chronicles\",\n      description: \"Cult book by Ray Bradbury\",\n      user: john,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/4/45/The-Martian-Chronicles.jpg\"\n    },\n    {\n      title: \"The Martian\",\n      description: \"Novel by Andy Weir about an astronaut stranded on Mars trying to survive\",\n      user: john,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/c/c3/The_Martian_2014.jpg\"\n    },\n    {\n      title: \"Doom\",\n      description: \"A group of Marines is sent to the red planet via an ancient \" \\\n                   \"Martian portal called the Ark to deal with an outbreak of a mutagenic virus\",\n      user: jane,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/5/57/Doom_cover_art.jpg\"\n    },\n    {\n      title: \"Mars Attacks!\",\n      description: \"Earth is invaded by Martians with unbeatable weapons and a cruel sense of humor\",\n      user: jane,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/b/bd/Mars_attacks_ver1.jpg\"\n    }\n  ]\n)\n</code></pre><p>Finally, we’re ready to initialize our database:</p><pre><code>$ rails db:create db:migrate db:seed\n</code></pre><p>Now that we’ve put some information into our system, let’s add a way to access it!</p><h2 id=\"adding-a-graphql-endpoint\">Adding a GraphQL endpoint</h2><p>For crafting our GraphQL API, we will use the <a href=\"https://github.com/rmosolgo/graphql-ruby\">graphql-ruby</a> gem:</p><pre><code># First, add it to the Gemfile\n$ bundle add graphql --version=\"~&gt; 1.9\"\n# Then, run the generator\n$ rails generate graphql:install\n</code></pre><p>You might be surprised by the number of files a minimal <code>graphql-ruby</code> application requires: this boilerplate is the price we pay for all the goodies we described above.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/generator-d6a5280.png\" class=\"kg-image\" alt=\"The result of executing generator\" loading=\"lazy\"><figcaption><p style=\"margin: 0px;\">The result of&nbsp;executing <code style=\"font-family: &quot;Fira Code&quot;, &quot;Lucida Console&quot;, Monaco, monospace; font-size: 1em; color: rgb(191, 108, 53); font-feature-settings: &quot;calt&quot;; text-rendering: optimizelegibility; white-space: pre-wrap;\">graphql:install</code> generator</p></figcaption></figure><p>First of all, let’s take a look at the schema, <code>martian_library_schema.rb</code>:</p><pre><code># app/graphql/martian_library_schema.rb\nclass MartianLibrarySchema &lt; GraphQL::Schema\n  query(Types::QueryType)\n  mutation(Types::MutationType)\nend\n</code></pre><p>The schema declares that all the queries should go to <code>Types::QueryType</code> while mutations should go to <code>Types::MutationType</code>. We’re going to dig deeper into mutations in the second part of the series; the goal of this article is to learn how to write and execute queries. Thus, let’s open the <code>types/query_type.rb</code> class—it is an entry point for all the queries. What’s inside?</p><pre><code># app/graphql/types/query_type.rb\nmodule Types\n  class QueryType &lt; Types::BaseObject\n    # Add root-level fields here.\n    # They will be entry points for queries on your schema.\n\n    # TODO: remove me\n    field :test_field, String, null: false,\n      description: \"An example field added by the generator\"\n    def test_field\n      \"Hello World!\"\n    end\n  end\nend\n</code></pre><p>It turns out that <code>QueryType</code> is just a regular type: it inherits from the <code>Types::BaseObject</code> (which we will use as a base class for all types), and it has <em>field</em> definitions–the nodes of our data graph. The only thing that makes <code>QueryType</code> different is that GraphQL requires this type to exist (while <em>mutation</em> and <em>subscription</em> types are optional).</p><p>Have noticed that the code above is actually a “hello world” app? Before going further (and boring you with by the amount of code), we’d like to show you how to get this “hello world” in your browser.</p><p>Let’s see what has been added to the <code>config/routes.rb</code> file by the generator:</p><pre><code># config/routes.rb\nRails.application.routes.draw do\n  mount GraphiQL::Rails::Engine, at: \"/graphiql\", graphql_path: \"/graphql\" if Rails.env.development?\n  post \"/graphql\", to: \"graphql#execute\"\nend\n</code></pre><p>Mounting <code>GraphiQL::Rails::Engine</code> allows us to test our queries and mutations using a web interface called <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a>. As we discussed in the introduction, the schema can be inspected, and GraphiQL uses this feature to build interactive documentation for us. It’s time to give it a shot!</p><pre><code># Let's run a Rails web server\n$ rails s\n</code></pre><p>Open up <a href=\"http://localhost:3000/graphiql\">http://localhost:3000/graphiql</a> in the browser:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/graphiql-4633e9d.png\" class=\"kg-image\" alt=\"GraphiQL UI\" loading=\"lazy\"><figcaption><p style=\"margin: 0px;\">GraphiQL UI</p></figcaption></figure><p>In the left pane, you can type a query to execute, then click the “play” button (or hit <em>Ctrl/Cmd+Enter</em>) and get the response in the right pane. By clicking the “Docs” link at the right top corner, you can explore your schema.</p><p>Let’s take a look at our logs—we want to know what happens when we click the execute button.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/execute_log-e654371.png\" class=\"kg-image\" alt=\"Execution logs\" loading=\"lazy\"><figcaption><p style=\"margin: 0px;\">Execution logs</p></figcaption></figure><p>GraphQL is transport-agnostic, but most implementations, including <code>ruby-graphql</code>, use HTTP POST requests.</p><p>Requests are sent to <code>GraphqlController</code>, which has also been added to the application by the <code>graphql</code> gem generator.</p><p>Take a look at the <code>GraphqlController#execute</code> action:</p><pre><code># app/controllers/graphql_controller.rb\ndef execute\n  variables = ensure_hash(params[:variables])\n  query = params[:query]\n  operation_name = params[:operationName]\n  context = {\n    # Query context goes here, for example:\n    # current_user: current_user,\n  }\n  result = GraphqlSchema.execute(\n    query,\n    variables: variables,\n    context: context,\n    operation_name: operation_name\n  )\n  render json: result\nrescue StandardError =&gt; e\n  raise e unless Rails.env.development?\n\n  handle_error_in_development e\nend\n</code></pre><p>This action calls the <code>GraphqlSchema#execute</code> method with the following parameters:</p><ul><li><code>query</code> and <code>variables</code> represent a query string and arguments sent by a client respectively;</li><li><code>context</code> is an arbitrary hash, which will be available during the query execution everywhere;</li><li><code>operation_name</code> picks a named operation from the incoming request to execute (could be empty).</li></ul><p>All the magic happens inside this method: it parses the query, detects all the types that should be used for building the response, and resolves all the requested fields. The only thing we need to do is to define the types and declare how fields should be resolved.</p><h2 id=\"what%E2%80%99s-in-the-martian-library\">What’s in the Martian Library?</h2><p>Let’s move from “hello world” to something real: remove the example contents from <code>Types::QueryType</code> and register a field called <code>:items</code> which will return all the items from the library. We also need to add a resolver method for this field (the resolver method name must match the field name):</p><pre><code># app/graphql/types/query_type.rb\nmodule Types\n  class QueryType &lt; Types::BaseObject\n    field :items,\n          [Types::ItemType],\n          null: false,\n          description: \"Returns a list of items in the martian library\"\n\n    def items\n      Item.all\n    end\n  end\nend\n</code></pre><p>Each field definition contains a name, a result type, and options; <code>:null</code> is required and must be set to either <code>true</code> or <code>false</code>. We also define optional <code>:description</code>—it’s a good practice to add a human-readable message to a field: it will be automatically added to documentation providing more context to developers. The array notation for the result type, <code>[Types::ItemType]</code>, means that the field value must be an array and each element of this array must be represented using the <code>Types::ItemType</code> type.</p><p>But we haven’t defined <code>ItemType</code> yet, right? Hopefully, the <code>graphql</code> gem will give us a handy generator:</p><pre><code>$ rails g graphql:object item\n</code></pre><p>Now we can modify the newly created <code>app/graphql/types/item_type.rb</code> to our liking.</p><pre><code># app/graphql/types/item_type.rb\nmodule Types\n  class ItemType &lt; Types::BaseObject\n    field :id, ID, null: false\n    field :title, String, null: false\n    field :description, String, null: true\n    field :image_url, String, null: true\n  end\nend\n</code></pre><p>You may use UUID as a primary key in your table if you are worried about exposing sequential IDs, but let’s go with the easy way now.</p><p>As you can see, we’re exposing three fields in <code>ItemType</code>:</p><ul><li>non-nullable fields <code>id</code> and <code>title</code></li><li>a nullable field <code>description</code></li></ul><p>Our execution engine resolves fields using the following algorithm (slightly simplified):</p><ul><li>First, it looks for the method with the same name defined in the type class itself (like we did earlier in the <code>QueryType</code> for <code>items</code>); we can access the object being resolved using the <code>object</code> method.</li><li>If no such method defined, it tries to call the method with the same name on the <code>object</code> itself.</li></ul><p>We do not define any methods in our type class; thus, we assume that the underlying implements all the fields’ methods.</p><p>Go back to <a href=\"http://localhost:3000/graphiql\">http://localhost:3000/graphiql</a>, execute the following query, and make sure that you get the list of all items in response:</p><pre><code>{\n  items {\n    id\n    title\n    description\n  }\n}\n</code></pre><p>So far, we haven’t added any functionality that leverages the power of graphs—our current graph’s depth is one. Let’s grow the graph by adding a non-primitive node to <code>ItemType</code>, for example, a <code>user</code> field to represent the user who created the item:</p><pre><code># app/graphql/types/item_type.rb\nmodule Types\n  class ItemType &lt; Types::BaseObject\n    # ...\n    field :user, Types::UserType, null: false\n  end\nend\n</code></pre><p>Let’s repeat the same generator spell to create a new type class:</p><pre><code>$ rails g graphql:object user\n</code></pre><p>This time we also want to add a computed field—<code>full_name</code>:</p><pre><code># app/graphql/types/user_type.rb\nmodule Types\n  class UserType &lt; Types::BaseObject\n    field :id, ID, null: false\n    field :email, String, null: false\n    field :full_name, String, null: false\n\n    def full_name\n      # `object` references the user instance\n      [object.first_name, object.last_name].compact.join(\" \")\n    end\n  end\nend\n</code></pre><p>Let’s transform our query to fetch users along with items:</p><pre><code>{\n  items {\n    id\n    title\n    user {\n      id\n      email\n    }\n  }\n}\n</code></pre><p>At this point, we’re ready to move our attention from the backend side to the frontend side. Let’s build a client for this API!</p><h2 id=\"configuring-the-frontend-application\">Configuring the frontend application</h2><p>If you’re using Google Chrome, mind installing the Apollo <a href=\"https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\">extension</a>.</p><p>As we already mentioned, we recommend you install the <a href=\"https://www.apollographql.com/docs/react/\">Apollo</a> framework for dealing with GraphQL client-side.</p><p>To get the ball rolling, we need to install all the required dependencies:</p><pre><code>$ yarn add apollo-client apollo-cache-inmemory apollo-link-http apollo-link-error apollo-link graphql graphql-tag react-apollo\n</code></pre><p>We didn’t include any package-adding types to JS (<a href=\"http://www.typescriptlang.org/\">TypeScript</a> or <a href=\"https://flow.org/\">Flow</a>) so as not to make this tutorial too complicated. In practice, using typed JS with GraphQL makes a lot of sense since we already have a types system. For instance, <a href=\"https://github.com/apollographql/apollo-tooling\">apollo-codegen</a> can generate type signatures automatically.</p><p>Let’s take a look at some of the installed packages:</p><ul><li>We use <code>graphql-tag</code> to build our first queries.</li><li><code>apollo-client</code> is a generic framework-agnostic package for performing and caching GraphQL requests.</li><li><code>apollo-cache-inmemory</code> is a storage implementation for Apollo cache.</li><li><code>react-apollo</code> contains a set of React components for displaying data.</li><li><code>apollo-link</code> and other <em>links</em> implement a middleware pattern for <code>apollo-client</code> operations (you can find further details <a href=\"https://www.apollographql.com/docs/link/overview.html\">here</a>).</li></ul><p>Now we need to create an entry point for our frontend application. Remove <code>hello_react.jsx</code> from the <code>packs</code> folder and add <code>index.js</code>:</p><pre><code>$ rm app/javascript/packs/hello_react.jsx &amp;&amp; touch app/javascript/packs/index.js\n</code></pre><p>For the sake of debugging, it’s good enough to stay with the following content:</p><pre><code>// app/javascript/packs/index.js\nconsole.log('👻');\n</code></pre><p>Let’s generate a controller to serve our frontend application:</p><pre><code>$ rails g controller Library index --skip-routes\n</code></pre><p>Update <code>app/views/library/index.html.erb</code> to contain the React root element and a link to our <em>pack</em>:</p><pre><code>&lt;!-- app/views/library/index.html.erb --&gt;\n&lt;div id=\"root\" /&gt;\n&lt;%= javascript_pack_tag 'index' %&gt;\n</code></pre><p>Finally, let’s register a new route in the <code>config/routes.rb</code>:</p><pre><code># config/routes.rb\nroot 'library#index'\n</code></pre><p>Restart your Rails server and make sure you see the ghost in the browser console. Don’t be scared.</p><h2 id=\"configuring-apollo\">Configuring Apollo</h2><p>Create a file for storing our application’s Apollo config:</p><pre><code>$ mkdir -p app/javascript/utils &amp;&amp; touch app/javascript/utils/apollo.js\n</code></pre><p>In this file we want to configure the two core entities of the Apollo application, the client and the cache (or more precisely, the functions to create both):</p><pre><code>// app/javascript/utils/apollo.js\n\n// client\nimport { ApolloClient } from 'apollo-client';\n// cache\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n// links\nimport { HttpLink } from 'apollo-link-http';\nimport { onError } from 'apollo-link-error';\nimport { ApolloLink, Observable } from 'apollo-link';\nexport const createCache = () =&gt; {\n  const cache = new InMemoryCache();\n  if (process.env.NODE_ENV === 'development') {\n    window.secretVariableToStoreCache = cache;\n  }\n  return cache;\n};\n</code></pre><p>Caching is one of the most powerful features of Apollo. Sometimes it becomes overpowering, and you might prefer a more straightforward solution. In any case, it’s worth learning how it works. Find more details about how Apollo caching works <a href=\"https://www.apollographql.com/docs/react/advanced/caching.html\">here</a>.</p><p>Let’s take a second and look at how cache works.</p><p>Each query response is put into the cache (the corresponding request is used to generate the cache key). Before making a request, <code>apollo-client</code> ensures that the response hasn’t been cached yet, and if it has been–the request is not performed. This behavior is configurable: for instance, we can turn off caching for a particular request or ask the client to look for a cache entry of a different query.</p><p>One important thing we need to know about the cache mechanism for this tutorial is that, by default, a cache key is a concatenation of the object <code>id</code> and <code>__typename</code>. Thus, fetching the same object twice would result only in one request.</p><p>Back to coding. Since we use HTTP POST as a transport, we need to attach a proper CSRF token to every request to pass the <a href=\"https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf\">forgery protection check</a> in the Rails app. We can grab it from <code>meta[name=\"csrf-token\"]</code> (which is generated by <code>&lt;%= csrf_meta_tags %&gt;</code>):</p><pre><code>// app/javascript/utils/apollo.js\n// ...\n// getToken from meta tags\nconst getToken = () =&gt;\n  document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content');\nconst token = getToken();\nconst setTokenForOperation = async operation =&gt;\n  operation.setContext({\n    headers: {\n      'X-CSRF-Token': token,\n    },\n  });\n// link with token\nconst createLinkWithToken = () =&gt;\n  new ApolloLink(\n    (operation, forward) =&gt;\n      new Observable(observer =&gt; {\n        let handle;\n        Promise.resolve(operation)\n          .then(setTokenForOperation)\n          .then(() =&gt; {\n            handle = forward(operation).subscribe({\n              next: observer.next.bind(observer),\n              error: observer.error.bind(observer),\n              complete: observer.complete.bind(observer),\n            });\n          })\n          .catch(observer.error.bind(observer));\n        return () =&gt; {\n          if (handle) handle.unsubscribe();\n        };\n      })\n  );\n</code></pre><p>Let’s look at how we can log errors:</p><pre><code>// app/javascript/utils/apollo.js\n//...\n// log erors\nconst logError = (error) =&gt; console.error(error);\n// create error link\nconst createErrorLink = () =&gt; onError(({ graphQLErrors, networkError, operation }) =&gt; {\n  if (graphQLErrors) {\n    logError('GraphQL - Error', {\n      errors: graphQLErrors,\n      operationName: operation.operationName,\n      variables: operation.variables,\n    });\n  }\n  if (networkError) {\n    logError('GraphQL - NetworkError', networkError);\n  }\n})\n</code></pre><p>In production, it makes more sense to use an exception tracking service (e.g., Sentry or Honeybadger): just override the <code>logError</code> function to send errors to the external system.</p><p>We’re almost there—let’s tell the client about the endpoint for making queries:</p><pre><code>// app/javascript/utils/apollo.js\n//...\n// http link\nconst createHttpLink = () =&gt; new HttpLink({\n  uri: '/graphql',\n  credentials: 'include',\n})\n</code></pre><p>Finally, we’re ready to create an Apollo client instance:</p><pre><code>// app/javascript/utils/apollo.js\n//...\nexport const createClient = (cache, requestLink) =&gt; {\n  return new ApolloClient({\n    link: ApolloLink.from([\n      createErrorLink(),\n      createLinkWithToken(),\n      createHttpLink(),\n    ]),\n    cache,\n  });\n};\n</code></pre><h2 id=\"the-very-first-query\">The very first query</h2><p>We’re going to use a <a href=\"https://reactjs.org/docs/context.html#contextprovider\">provider pattern</a> to pass the client instances to React components:</p><pre><code>$ mkdir -p app/javascript/components/Provider &amp;&amp; touch app/javascript/components/Provider/index.js\n</code></pre><p>It’s the first time we are using an <code>ApolloProvider</code> component from the <code>react-apollo</code> library:</p><pre><code>// app/javascript/components/Provider/index.js\nimport React from 'react';\nimport { ApolloProvider } from 'react-apollo';\nimport { createCache, createClient } from '../../utils/apollo';\n\nexport default ({ children }) =&gt; (\n  &lt;ApolloProvider client={createClient(createCache())}&gt;\n    {children}\n  &lt;/ApolloProvider&gt;\n);\n</code></pre><p>Let’s change our <code>index.js</code> to use the newly created provider:</p><pre><code>// app/javascript/packs/index.js\nimport React from 'react';\nimport { render } from 'react-dom';\nimport Provider from '../components/Provider';\n\nrender(&lt;Provider&gt;👻&lt;/Provider&gt;, document.querySelector('#root'));\n</code></pre><p>If you use <code>Webpacker v3</code> you may need to import <code>babel-polyfill</code> to use all the cool JavaScript tricks like async/await. Don’t worry about the polyfill’s size; <code>babel-preset-env</code> will remove everything you don’t need.</p><p>Let’s create a <code>Library</code> component to display the list of items on the page:</p><pre><code>$ mkdir -p app/javascript/components/Library &amp;&amp; touch app/javascript/components/Library/index.js\n</code></pre><p>We’re going to use the <code>Query</code> component from <code>react-apollo</code>, which accepts the <code>query</code> string as a property to fetch the data on mount:</p><pre><code>// app/javascript/components/Library/index.js\nimport React from 'react';\nimport { Query } from 'react-apollo';\nimport gql from 'graphql-tag';\n\nconst LibraryQuery = gql`\n  {\n    items {\n      id\n      title\n      user {\n        email\n      }\n    }\n  }\n`;\n\nexport default () =&gt; (\n  &lt;Query query={LibraryQuery}&gt;\n    {({ data, loading }) =&gt; (\n      &lt;div&gt;\n        {loading\n          ? 'loading...'\n          : data.items.map(({ title, id, user }) =&gt; (\n              &lt;div key={id}&gt;\n                &lt;b&gt;{title}&lt;/b&gt; {user ? `added by ${user.email}` : null}\n              &lt;/div&gt;\n            ))}\n      &lt;/div&gt;\n    )}\n  &lt;/Query&gt;\n);\n</code></pre><p>We can access the loading state and loaded data through the corresponding <code>loading</code> and <code>data</code> properties (passed using a so-called <a href=\"https://reactjs.org/docs/render-props.html\">render-props pattern</a>).</p><p>Don’t forget to add the component to the main page:</p><pre><code>// app/javascript/packs/index.js\nimport React from 'react';\nimport { render } from 'react-dom';\nimport Provider from '../components/Provider';\nimport Library from '../components/Library';\n\nrender(\n  &lt;Provider&gt;\n    &lt;Library /&gt;\n  &lt;/Provider&gt;,\n  document.querySelector('#root')\n);\n</code></pre><p>If you reload the page you should see the list of items with emails of users who added them:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/items-b791b9f.png\" class=\"kg-image\" alt=\"List of items with emails of users\" loading=\"lazy\"><figcaption><p style=\"margin: 0px;\">List of&nbsp;items with emails of&nbsp;users</p></figcaption></figure><p>Congratulations! You’ve just made the very first step towards GraphQL happiness!</p><h2 id=\"%E2%80%A6and-the-very-first-problem\">…And the very first problem</h2><p>Everything seems to work fine, but let’s take a look at our server logs:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/n_plus_one-77d1121.png\" class=\"kg-image\" alt=\"N + 1\" loading=\"lazy\"><figcaption><p style=\"margin: 0px;\">N + 1</p></figcaption></figure><p>The SQL query <code>SELECT * FROM users WHERE id = ?</code> is executed <strong>four times</strong>, which means that we hit the famous <em>N+1 problem</em>–server makes a query for each item in the collection to get the corresponding user info.</p><p>Before fixing the problem, we need to make sure that it’s safe to make code modifications without breaking anything—let’s write some tests!</p><h2 id=\"writing-some-specs\">Writing some specs</h2><p>Since we’re running on the edge, we need the upcoming version of the gem.</p><p>Now it’s time to install and configure RSpec, or more precisely, the <code>rspec-rails</code> gem:</p><pre><code># Add gem to the Gemfile\n$ bundle add rspec-rails --version=\"4.0.0.beta2\" --group=\"development,test\"\n# Generate the initial configuration\n$ rails generate rspec:install\n</code></pre><p>To make it easier to generate data for tests let’s install <a href=\"https://github.com/thoughtbot/factory_bot\">factory_bot</a>:</p><pre><code>$ bundle add factory_bot_rails --version=\"~&gt; 5.0\" --group=\"development,test\"\n</code></pre><p>Make factory methods (<code>create</code>, <code>build</code>, etc.) globally visible in tests by adding <code>config.include FactoryBot::Syntax::Methods</code> to the <code>rails_helper.rb</code>.</p><p>Since we created our models before adding Factory Bot, we should generate our factories manually. Let’s create a single file, <code>spec/factories.rb</code>, for that:</p><pre><code># spec/factories.rb\nFactoryBot.define do\n  factory :user do\n    # Use sequence to make sure that the value is unique\n    sequence(:email) { |n| \"user-#{n}@example.com\" }\n  end\n\n  factory :item do\n    sequence(:title) { |n| \"item-#{n}\" }\n    user\n  end\nend\n</code></pre><p>Now we are ready to write our first test. Let’s create a spec file for <code>QueryType</code>:</p><pre><code>$ mkdir -p spec/graphql/types\n$ touch spec/graphql/types/query_type_spec.rb\n</code></pre><p>The simplest query test looks like this:</p><pre><code># spec/graphql/types/query_type_spec.rb\nrequire \"rails_helper\"\n\nRSpec.describe Types::QueryType do\n  describe \"items\" do\n    let!(:items) { create_pair(:item) }\n\n    let(:query) do\n      %(query {\n        items {\n          title\n        }\n      })\n    end\n\n    subject(:result) do\n      MartianLibrarySchema.execute(query).as_json\n    end\n\n    it \"returns all items\" do\n      expect(result.dig(\"data\", \"items\")).to match_array(\n        items.map { |item| { \"title\" =&gt; item.title } }\n      )\n    end\n  end\nend\n</code></pre><p>Testing GraphQL might feel repetitive. Should it happen to you—consider using fixtures and the <a href=\"https://github.com/nepalez/fixturama\">fixturama</a> gem.</p><p>First, we create a pair of items in our database. Then, we define the query under test and the subject (<code>result</code>) by calling the <code>GraphqlSchema.execute</code> method. Remember, we had a similar line in the <code>GraphqlController#execute</code>?</p><p>This example is very straightforward: we’re not passing either <code>variables</code> or <code>context</code> to the <code>execute</code> call, though we definitely can do that if needed.</p><p>Now we’re confident enough to fix “the bug”—the N+1 problem!</p><h2 id=\"graphql-vs-n1-problem\">GraphQL vs. N+1 problem</h2><p>The easiest way to avoid N+1 queries is to use <a href=\"https://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations\">eager loading</a>. In our case, we need to preload users when making a query to fetch items in <code>QueryType</code>:</p><pre><code># /app/graphql/types/query_type.rb\nmodule Types\n  class QueryType &lt; Types::BaseObject\n    # ...\n\n    def items\n      Item.preload(:user)\n    end\n  end\nend\n</code></pre><p>This solution can help in simple situations, but it’s not very efficient: the following code preloads users even if the client does not need them, e.g.:</p><pre><code>items {\n  title\n}\n</code></pre><p>Learn how to solve the N+1 problem using batch loading by example from the <a href=\"https://dev.to/evilmartians/active-storage-meets-graphql-pt-2-exposing-attachment-urls-2mdn\">“Active Storage meets GraphQL”</a> post in our dev.to blog.</p><p>Discussing other ways to solve the N+1 problem is worthy of a dedicated post and out of this tutorial’s scope.<br>Most of the solutions fit the following two groups:</p><ul><li>lazy eager loading (e.g., using the <a href=\"https://github.com/DmitryTsepelev/ar_lazy_preload\">ar_lazy_preload</a> gem)</li><li>batch loading (e.g., using the <a href=\"https://github.com/Shopify/graphql-batch\">graphql-batch</a> gem)</li></ul><hr><p>That’s all for today! We learned a lot about GraphQL, completed all the routine work of configuring the backend and frontend applications, made the first query, and even found and fixed the first bug. And that’s just a tiny step (despite the size of the article) in our journey. We’ll come back shortly and unveil how to manipulate data using GraphQL mutations and keep it up-to-date with subscriptions. Stay tuned!</p>","url":"https://iron.fordeer.agency/graphql-on-rails-from-zero-to-the-first-query/","canonical_url":null,"uuid":"89206142-5fb7-419a-ac5d-ffe96222b0f2","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"612e07af894d3804d9ca6d95","reading_time":17}},{"node":{"id":"Ghost__Post__612df6616c623f9319ddfd28","title":"Building your audience with subscriber signups","slug":"portal","featured":false,"feature_image":"https://static.ghost.org/v4.0.0/images/creating-a-custom-theme.png","excerpt":"How Ghost allows you to turn anonymous readers into an audience of active subscribers, so you know what's working and what isn't.","custom_excerpt":"How Ghost allows you to turn anonymous readers into an audience of active subscribers, so you know what's working and what isn't.","visibility":"public","created_at_pretty":"31 August, 2021","published_at_pretty":"31 August, 2021","updated_at_pretty":"31 August, 2021","created_at":"2021-08-31T16:29:05.000+07:00","published_at":"2021-08-31T16:29:07.000+07:00","updated_at":"2021-08-31T16:29:05.000+07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"}],"primary_author":{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"},"primary_tag":{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"What sets Ghost apart from other products is that you can publish content and\ngrow your audience using the same platform. Rather than just endlessly posting\nand hoping someone is listening, you can track real signups against your work\nand have them subscribe to be notified of future posts. The feature that makes\nall this possible is called Portal.\n\nPortal is an embedded interface for your audience to sign up to your site. It\nworks on every Ghost site, with every theme, and for any type of publisher. \n\nYou can customize the design, content and settings of Portal to suit your site,\nwhether you just want people to sign up to your newsletter — or you're running a\nfull premium publication with user sign-ins and private content.\n\nOnce people sign up to your site, they'll receive an email confirmation with a\nlink to click. The link acts as an automatic sign-in, so subscribers will be\nautomatically signed-in to your site when they click on it. There are a couple\nof interesting angles to this:\n\nBecause subscribers are automatically able to sign in and out of your site as\nregistered members: You can (optionally) restrict access to posts and pages\ndepending on whether people are signed-in or not. So if you want to publish some\nposts for free, but keep some really great stuff for members-only, this can be a\ngreat draw to encourage people to sign up!\n\nGhost members sign in using email authentication links, so there are no\npasswords for people to set or forget. You can turn any list of email\nsubscribers into a database of registered members who can sign in to your site.\nLike magic.\n\nPortal makes all of this possible, and it appears by default as a floating\nbutton in the bottom-right corner of your site. When people are logged out,\nclicking it will open a sign-up/sign-in window. When members are logged in,\nclicking the Portal button will open the account menu where they can edit their\nname, email, and subscription settings.\n\nThe floating Portal button is completely optional. If you prefer, you can add\nmanual links to your content, navigation, or theme to trigger it instead.\n\nLike this! Sign up here\n\n\n--------------------------------------------------------------------------------\n\nAs you start to grow your registered audience, you'll be able to get a sense of\nwho you're publishing for and where those people are coming from. Best of all:\nYou'll have a straightforward, reliable way to connect with people who enjoy\nyour work.\n\nSocial networks go in and out of fashion all the time. Email addresses are\ntimeless.\n\nGrowing your audience is valuable no matter what type of site you run, but if\nyour content is your business, then you might also be interested in setting up\npremium subscriptions [https://iron.fordeer.agency/sell/].","html":"<p>What sets Ghost apart from other products is that you can publish content and grow your audience using the same platform. Rather than just endlessly posting and hoping someone is listening, you can track real signups against your work and have them subscribe to be notified of future posts. The feature that makes all this possible is called <em>Portal</em>.</p><p>Portal is an embedded interface for your audience to sign up to your site. It works on every Ghost site, with every theme, and for any type of publisher. </p><p>You can customize the design, content and settings of Portal to suit your site, whether you just want people to sign up to your newsletter — or you're running a full premium publication with user sign-ins and private content.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://static.ghost.org/v4.0.0/images/portalsettings.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"2924\" height=\"1810\"></figure><p>Once people sign up to your site, they'll receive an email confirmation with a link to click. The link acts as an automatic sign-in, so subscribers will be automatically signed-in to your site when they click on it. There are a couple of interesting angles to this:</p><p>Because subscribers are automatically able to sign in and out of your site as registered members: You can (optionally) restrict access to posts and pages depending on whether people are signed-in or not. So if you want to publish some posts for free, but keep some really great stuff for members-only, this can be a great draw to encourage people to sign up!</p><p>Ghost members sign in using email authentication links, so there are no passwords for people to set or forget. You can turn any list of email subscribers into a database of registered members who can sign in to your site. Like magic.</p><p>Portal makes all of this possible, and it appears by default as a floating button in the bottom-right corner of your site. When people are logged out, clicking it will open a sign-up/sign-in window. When members are logged in, clicking the Portal button will open the account menu where they can edit their name, email, and subscription settings.</p><p>The floating Portal button is completely optional. If you prefer, you can add manual links to your content, navigation, or theme to trigger it instead.</p><p>Like this! <a href=\"#/portal\">Sign up here</a></p><hr><p>As you start to grow your registered audience, you'll be able to get a sense of who you're publishing <em>for</em> and where those people are coming <em>from</em>. Best of all: You'll have a straightforward, reliable way to connect with people who enjoy your work.</p><p>Social networks go in and out of fashion all the time. Email addresses are timeless.</p><p>Growing your audience is valuable no matter what type of site you run, but if your content <em>is</em> your business, then you might also be interested in <a href=\"https://iron.fordeer.agency/sell/\">setting up premium subscriptions</a>.</p>","url":"https://iron.fordeer.agency/portal/","canonical_url":null,"uuid":"ad525305-5cb8-4e52-9358-9fe11ada34ff","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"612df6616c623f9319ddfd28","reading_time":2}},{"node":{"id":"Ghost__Post__612df6616c623f9319ddfd26","title":"Selling premium memberships with recurring revenue","slug":"sell","featured":false,"feature_image":"https://static.ghost.org/v4.0.0/images/organizing-your-content.png","excerpt":"For creators and aspiring entrepreneurs looking to generate a sustainable\nrecurring revenue stream from their creative work, Ghost has built-in payments\nallowing you to create a subscription commerce business.\n\nConnect your Stripe [https://stripe.com] account to Ghost, and you'll be able to\nquickly and easily create monthly and yearly premium plans for members to\nsubscribe to, as well as complimentary plans for friends and family.\n\nGhost takes 0% payment fees, so everything you make is yours to ","custom_excerpt":null,"visibility":"paid","created_at_pretty":"31 August, 2021","published_at_pretty":"31 August, 2021","updated_at_pretty":"31 August, 2021","created_at":"2021-08-31T16:29:05.000+07:00","published_at":"2021-08-31T16:29:06.000+07:00","updated_at":"2021-08-31T16:29:05.000+07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"}],"primary_author":{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"},"primary_tag":{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"For creators and aspiring entrepreneurs looking to generate a sustainable\nrecurring revenue stream from their creative work, Ghost has built-in payments\nallowing you to create a subscription commerce business.\n\nConnect your Stripe [https://stripe.com] account to Ghost, and you'll be able to\nquickly and easily create monthly and yearly premium plans for members to\nsubscribe to, as well as complimentary plans for friends and family.\n\nGhost takes 0% payment fees, so everything you make is yours to keep!\n\nUsing subscriptions, you can build an independent media business like \nStratechery [https://stratechery.com], The Information\n[https://www.theinformation.com], or The Browser [https://thebrowser.com].\n\nThe creator economy is just getting started, and Ghost allows you to build\nsomething based on technology that you own and control.\n\n[https://thebrowser.com]The Browser has over 10,000 paying subscribersMost\nsuccessful subscription businesses publish a mix of free and paid posts to\nattract a new audience, and upsell the most loyal members to a premium offering.\nYou can also mix different access levels within the same post, showing a free\npreview to logged out members and then, right when you're ready for a\ncliffhanger, that's a good time to...","html":"<p>For creators and aspiring entrepreneurs looking to generate a sustainable recurring revenue stream from their creative work, Ghost has built-in payments allowing you to create a subscription commerce business.</p><p>Connect your <a href=\"https://stripe.com\">Stripe</a> account to Ghost, and you'll be able to quickly and easily create monthly and yearly premium plans for members to subscribe to, as well as complimentary plans for friends and family.</p><p>Ghost takes <strong>0% payment fees</strong>, so everything you make is yours to keep!</p><p>Using subscriptions, you can build an independent media business like <a href=\"https://stratechery.com\">Stratechery</a>, <a href=\"https://www.theinformation.com\">The Information</a>, or <a href=\"https://thebrowser.com\">The Browser</a>.</p><p>The creator economy is just getting started, and Ghost allows you to build something based on technology that you own and control.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><a href=\"https://thebrowser.com\"><img src=\"https://static.ghost.org/v4.0.0/images/thebrowser.jpg\" class=\"kg-image\" alt loading=\"lazy\" width=\"1600\" height=\"2000\"></a><figcaption>The Browser has over 10,000 paying subscribers</figcaption></figure><p>Most successful subscription businesses publish a mix of free and paid posts to attract a new audience, and upsell the most loyal members to a premium offering. You can also mix different access levels within the same post, showing a free preview to logged out members and then, right when you're ready for a cliffhanger, that's a good time to...</p>","url":"https://iron.fordeer.agency/sell/","canonical_url":null,"uuid":"db0a1ebb-5854-4403-9802-e2153597464b","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"612df6616c623f9319ddfd26","reading_time":1}},{"node":{"id":"Ghost__Post__612df6616c623f9319ddfd24","title":"How to grow your business around an audience","slug":"grow","featured":false,"feature_image":"https://static.ghost.org/v4.0.0/images/admin-settings.png","excerpt":"A guide to collaborating with other staff users to publish, and some resources to help you with the next steps of growing your business","custom_excerpt":"A guide to collaborating with other staff users to publish, and some resources to help you with the next steps of growing your business","visibility":"public","created_at_pretty":"31 August, 2021","published_at_pretty":"31 August, 2021","updated_at_pretty":"31 August, 2021","created_at":"2021-08-31T16:29:05.000+07:00","published_at":"2021-08-31T16:29:05.000+07:00","updated_at":"2021-08-31T16:29:05.000+07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"}],"primary_author":{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"},"primary_tag":{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"As you grow, you'll probably want to start inviting team members and\ncollaborators to your site. Ghost has a number of different user roles for your\nteam:\n\nContributors\nThis is the base user level in Ghost. Contributors can create and edit their own\ndraft posts, but they are unable to edit drafts of others or publish posts.\nContributors are untrusted users with the most basic access to your publication.\n\nAuthors\nAuthors are the 2nd user level in Ghost. Authors can write, edit and publish\ntheir own posts. Authors are trusted users. If you don't trust users to be\nallowed to publish their own posts, they should be set as Contributors.\n\nEditors\nEditors are the 3rd user level in Ghost. Editors can do everything that an\nAuthor can do, but they can also edit and publish the posts of others - as well\nas their own. Editors can also invite new Contributors & Authors to the site.\n\nAdministrators\nThe top user level in Ghost is Administrator. Again, administrators can do\neverything that Authors and Editors can do, but they can also edit all site\nsettings and data, not just content. Additionally, administrators have full\naccess to invite, manage or remove any other user of the site.\n\nThe Owner\nThere is only ever one owner of a Ghost site. The owner is a special user which\nhas all the same permissions as an Administrator, but with two exceptions: The\nOwner can never be deleted. And in some circumstances the owner will have access\nto additional special settings if applicable. For example: billing details, if\nusing Ghost(Pro) [https://ghost.org/pricing/].\n\n> Ask all of your users to fill out their user profiles, including bio and social\nlinks. These will populate rich structured data for posts and generally create\nmore opportunities for themes to fully populate their design.\n\n--------------------------------------------------------------------------------\n\nIf you're looking for insights, tips and reference materials to expand your\ncontent business, here's 5 top resources to get you started:\n\n * How to create a premium newsletter (+ some case studies)\n   [https://ghost.org/blog/how-to-create-a-newsletter/] \n   Learn how others run successful paid email newsletter products\n * The ultimate guide to membership websites for creators\n   [https://ghost.org/blog/membership-sites/]\n   Tips to help you build, launch and grow your new membership business\n * The Newsletter Guide [https://newsletterguide.org/]\n   A 201 guide for taking your newsletters to the next level\n * The proven way to find your niche, explained\n   [https://ghost.org/blog/find-your-niche-creator-economy/]\n   Find the overlap and find a monetizable niche that gets noticed\n * Should you launch a referral program?\n   [https://ghost.org/blog/newsletter-referral-programs/]\n   Strategies for building a sustainable referral growth machine","html":"<p>As you grow, you'll probably want to start inviting team members and collaborators to your site. Ghost has a number of different user roles for your team:</p><p><strong>Contributors</strong><br>This is the base user level in Ghost. Contributors can create and edit their own draft posts, but they are unable to edit drafts of others or publish posts. Contributors are <strong>untrusted</strong> users with the most basic access to your publication.</p><p><strong>Authors</strong><br>Authors are the 2nd user level in Ghost. Authors can write, edit and publish their own posts. Authors are <strong>trusted</strong> users. If you don't trust users to be allowed to publish their own posts, they should be set as Contributors.</p><p><strong>Editors</strong><br>Editors are the 3rd user level in Ghost. Editors can do everything that an Author can do, but they can also edit and publish the posts of others - as well as their own. Editors can also invite new Contributors &amp; Authors to the site.</p><p><strong>Administrators</strong><br>The top user level in Ghost is Administrator. Again, administrators can do everything that Authors and Editors can do, but they can also edit all site settings and data, not just content. Additionally, administrators have full access to invite, manage or remove any other user of the site.<br><br><strong>The Owner</strong><br>There is only ever one owner of a Ghost site. The owner is a special user which has all the same permissions as an Administrator, but with two exceptions: The Owner can never be deleted. And in some circumstances the owner will have access to additional special settings if applicable. For example: billing details, if using <a href=\"https://ghost.org/pricing/\"><strong>Ghost(Pro)</strong></a>.</p><blockquote><em>Ask all of your users to fill out their user profiles, including bio and social links. These will populate rich structured data for posts and generally create more opportunities for themes to fully populate their design.</em></blockquote><hr><p>If you're looking for insights, tips and reference materials to expand your content business, here's 5 top resources to get you started:</p><ul><li><a href=\"https://ghost.org/blog/how-to-create-a-newsletter/\"><strong>How to create a premium newsletter (+ some case studies)</strong></a><strong> </strong> <br>Learn how others run successful paid email newsletter products</li><li><strong><a href=\"https://ghost.org/blog/membership-sites/\">The ultimate guide to membership websites for creators</a></strong><br>Tips to help you build, launch and grow your new membership business</li><li><strong><a href=\"https://newsletterguide.org/\">The Newsletter Guide</a></strong><br>A 201 guide for taking your newsletters to the next level</li><li><a href=\"https://ghost.org/blog/find-your-niche-creator-economy/\"><strong>The proven way to find your niche, explained</strong></a><br>Find the overlap and find a monetizable niche that gets noticed</li><li><strong><a href=\"https://ghost.org/blog/newsletter-referral-programs/\">Should you launch a referral program? </a></strong><br>Strategies for building a sustainable referral growth machine</li></ul>","url":"https://iron.fordeer.agency/grow/","canonical_url":null,"uuid":"a974eb9d-f201-4f24-abb8-3515e4f90cce","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"612df6616c623f9319ddfd24","reading_time":2}}]}},"pageContext":{"pageNumber":0,"humanPageNumber":1,"skip":0,"limit":12,"numberOfPages":1,"previousPagePath":"","nextPagePath":""}},"staticQueryHashes":["176528973","2358152166","2561578252","2731221146","4145280475"]}