{"componentChunkName":"component---src-templates-index-js","path":"/","result":{"data":{"allGhostPost":{"edges":[{"node":{"id":"Ghost__Post__612e07af894d3804d9ca6d95","title":"GraphQL on Rails:\nFrom zero to the first query","slug":"graphql-on-rails-from-zero-to-the-first-query","featured":false,"feature_image":"https://iron.fordeer.agency/content/images/2021/08/cover-41f83d0.png","excerpt":"A hitchhiker‚Äôs guide to developing GraphQL applications with Rails on the\nbackend side and React/Apollo on the frontend side. Follow this multi-part\ntutorial to learn both the basics and the advanced topics by example and feel\nthe power of this modern technology.\n\nGraphQL [https://graphql.org/] is one of those new shiny things we‚Äôve been\nseeing here, there and everywhere: blog posts\n[https://dev.to/evilmartians/exposing-permissions-in-graphql-apis-with-action-policy-536a-temp-slug-455298?preview","custom_excerpt":null,"visibility":"public","created_at_pretty":"31 August, 2021","published_at_pretty":"31 August, 2021","updated_at_pretty":"31 August, 2021","created_at":"2021-08-31T17:42:55.000+07:00","published_at":"2021-08-31T17:45:05.000+07:00","updated_at":"2021-08-31T17:45:04.000+07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"IRON","slug":"iron","bio":null,"profile_image":"https://iron.fordeer.agency/content/images/2021/08/T-Banners-Icons-S14-HighTowerTomato-L.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"IRON","slug":"iron","bio":null,"profile_image":"https://iron.fordeer.agency/content/images/2021/08/T-Banners-Icons-S14-HighTowerTomato-L.png","twitter":null,"facebook":null,"website":null},"primary_tag":null,"tags":[],"plaintext":"A hitchhiker‚Äôs guide to developing GraphQL applications with Rails on the\nbackend side and React/Apollo on the frontend side. Follow this multi-part\ntutorial to learn both the basics and the advanced topics by example and feel\nthe power of this modern technology.\n\nGraphQL [https://graphql.org/] is one of those new shiny things we‚Äôve been\nseeing here, there and everywhere: blog posts\n[https://dev.to/evilmartians/exposing-permissions-in-graphql-apis-with-action-policy-536a-temp-slug-455298?preview=5921586e85991fd5515f56b0ab8401d5fa1acb757e53ffc9c32c06243664d434f816c731482815c58f8a058def1cc2ae05638aacfce6c09d473010dc]\n, conferences [https://www.graphqlconf.org/], podcasts\n[https://graphqlradio.com/], maybe, even newspapers. It sounds like you should\nhurry up and start rewriting your application in GraphQL instead of REST as soon\nas possible, right? Not exactly. Remember: there is no silver bullet. It‚Äôs\nessential to understand the pros and cons of the technology before making a\nparadigm-shift decision.\n\nCheck out Part 2\n[https://evilmartians.com/chronicles/graphql-on-rails-2-updating-the-data] and \nPart 3\n[https://evilmartians.com/chronicles/graphql-on-rails-3-on-the-way-to-perfection]\n\nIn this series, we‚Äôre going to walk you through a no-frills guide to the\ndevelopment of GraphQL applications, talking about not only its advantages but\nalso its caveats and pitfalls (and, of course, the ways to deal with them).\n\nGraphQL in a nutshell\nThere are a lot of other query languages, for instance, SQL and XPath.\n\nAccording to the specification [https://graphql.github.io/graphql-spec/],\nGraphQL is a query language and runtime (or execution engine). Query language, \nby definition [https://en.wikipedia.org/wiki/Query_language], describes how to\ncommunicate with an information system. Runtime is responsible for fulfilling\nqueries with data.\n\nAt the core of every GraphQL application lies a schema\n[https://graphql.org/learn/schema/]: it describes the underlying data in the\nform of a directed graph. The runtime must execute queries according to the\nschema (and some general rules from the specification). That means, every valid\nGraphQL server runs queries in the same manner and returns data in the same\nformat for the same schema. In other words, the schema is everything clients\nshould know about the API.\n\nHere is an example of a simple GraphQL query:\n\nquery getProduct($id: Int!) {\n  product(id: $id) {\n    id\n    title\n    manufacturer {\n      name\n    }\n  }\n}\n\n\nLet‚Äôs dissect it line by line:\n\n * We define a named query (getProduct is the operation name) accepting a single\n   argument ($id). The operation name is optional, but it helps readability and\n   could be used by frontend for caching.\n * We ‚Äúselect‚Äù the product field from the ‚Äúroot‚Äù of the schema and pass the $id \n   value as an argument.\n * We describe the fields we want to fetch: in this case, we want to get the id \n   and title of the product as well as the name of the manufacturer.\n\n> Essentially, a query represents a sub-graph of the schema, which brings the\nfirst benefit of GraphQL‚Äîwe can fetch only this data we need and all we need at\nonce, in a single query.\nCheck out this Stack Overflow post\n[https://stackoverflow.com/questions/44564905/what-is-over-fetching-or-under-fetching] \nto learn more about both overfetching and underfetching.\n\nThis way, we solve one of the common problems of the traditional REST APIs‚Äî\noverfetching.\n\nAnother noticeable feature of GraphQL schemas is they are strongly typed: both\nclient and runtime ensure that the data passed is valid from the perspective of\nthe application‚Äôs type system. For example, if someone mistakenly passes a\nstring value as the $id to the query above, the client fails with the exception\nwithout even trying to perform a request.\n\nThere are plenty of tools to convert a schema into an interactive documentation\nwebsite, standalone (e.g., GraphiQL [https://github.com/graphql/graphiql] or \ngraphdoc [https://2fd.github.io/graphdoc]) and framework-specific (e.g., Apollo\nDevTools\n[https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm]\n).\n\nAnd the last but not least bonus is a schema introspection: clients can learn\nthe API from the schema itself, without any additional documentation sources.\n\nWe‚Äôve just learned a bunch of theoretical aspects of GraphQL. Now it‚Äôs time to\ndo some coding exercises to make sure you won‚Äôt forget everything tomorrow‚Äôs\nmorning.\n\nWhat are we going to build?\nDuring this series, we will be building an application representing a ‚ÄúMartian\nLibrary‚Äù‚Äîa personal online collection of movies, books, and other art objects\nrelated to the Red Planet.\n\nThe application we are going to¬†build\n\nFor this tutorial, we‚Äôre going to use:\n\n * Ruby 2.6 and Rails 6 (release candidate is already here\n   [https://evilmartians.com/chronicles/rails-6-b-sides-and-rarities]) for\n   backend.\n * Node.js 9+, React 16.3+, and Apollo (client version 2+) for frontend (and\n   make sure you have yarn installed according to the instruction\n   [https://yarnpkg.com/en/docs/install#mac-stable]).\n\nYou can find the source code here\n[https://github.com/evilmartians/chronicles-gql-martian-library/tree/part-1]\n‚Äîdon‚Äôt forget to run bundle install && yarn install before the first run. Master\n[https://github.com/evilmartians/chronicles-gql-martian-library] represents a\ncurrent state of the project.\n\nSetting up a new Rails project\nIf at the time of reading this article Rails 6.0 hasn‚Äôt been released yet, you\nmight need to install the release candidate first:\n\n$ gem install rails --pre\n$ rails -v\n=> Rails 6.0.0.rc1\n\n\nNow we‚Äôre ready to run this unexpectedly long rails new command:\n\n$ rails new martian-library -d postgresql --skip-action-mailbox --skip-action-text --skip-spring --webpack=react -T --skip-turbolinks\n\n\nWe prefer okonomi to omakase [https://dhh.dk/2012/rails-is-omakase.html]: skip\nframeworks and libraries we don‚Äôt need, choose PostgreSQL as our database,\npreconfigure Webpacker to use React, and skip tests (don‚Äôt worry‚Äìwe‚Äôll add RSpec\nsoon).\n\nBefore you start, it‚Äôs strongly recommended that you disable all the unnecessary\ngenerators in theconfig/application.rb:\n\nconfig.generators do |g|\n  g.test_framework  false\n  g.stylesheets     false\n  g.javascripts     false\n  g.helper          false\n  g.channel         assets: false\nend\n\n\nPreparing the data model\nWe need at least two models to start:\n\n * Item to describe any entity (book, movie, etc.) that we want to store in the\n   library\n * User to represent the application user who can manage items in the\n   collection.\n\nLet‚Äôs generate them:\n\n$ rails g model User first_name last_name email\n$ rails g model Item title description:text image_url user:references\n\n\nDon‚Äôt forget to add the has_many :items association to app/models/user.rb:\n\n# app/models/user.rb\nclass User < ApplicationRecord\n  has_many :items, dependent: :destroy\nend\n\n\nLet‚Äôs add some pre-generated data to db/seeds.rb:\n\n# db/seeds.rb\njohn = User.create!(\n  email: \"john.doe@example.com\",\n  first_name: \"John\",\n  last_name: \"Doe\"\n)\n\njane = User.create!(\n  email: \"jane.doe@example.com\",\n  first_name: \"Jane\",\n  last_name: \"Doe\"\n)\n\nItem.create!(\n  [\n    {\n      title: \"Martian Chronicles\",\n      description: \"Cult book by Ray Bradbury\",\n      user: john,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/4/45/The-Martian-Chronicles.jpg\"\n    },\n    {\n      title: \"The Martian\",\n      description: \"Novel by Andy Weir about an astronaut stranded on Mars trying to survive\",\n      user: john,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/c/c3/The_Martian_2014.jpg\"\n    },\n    {\n      title: \"Doom\",\n      description: \"A group of Marines is sent to the red planet via an ancient \" \\\n                   \"Martian portal called the Ark to deal with an outbreak of a mutagenic virus\",\n      user: jane,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/5/57/Doom_cover_art.jpg\"\n    },\n    {\n      title: \"Mars Attacks!\",\n      description: \"Earth is invaded by Martians with unbeatable weapons and a cruel sense of humor\",\n      user: jane,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/b/bd/Mars_attacks_ver1.jpg\"\n    }\n  ]\n)\n\n\nFinally, we‚Äôre ready to initialize our database:\n\n$ rails db:create db:migrate db:seed\n\n\nNow that we‚Äôve put some information into our system, let‚Äôs add a way to access\nit!\n\nAdding a GraphQL endpoint\nFor crafting our GraphQL API, we will use the graphql-ruby\n[https://github.com/rmosolgo/graphql-ruby] gem:\n\n# First, add it to the Gemfile\n$ bundle add graphql --version=\"~> 1.9\"\n# Then, run the generator\n$ rails generate graphql:install\n\n\nYou might be surprised by the number of files a minimal graphql-ruby application\nrequires: this boilerplate is the price we pay for all the goodies we described\nabove.\n\nThe result of¬†executing graphql:install generator\n\nFirst of all, let‚Äôs take a look at the schema, martian_library_schema.rb:\n\n# app/graphql/martian_library_schema.rb\nclass MartianLibrarySchema < GraphQL::Schema\n  query(Types::QueryType)\n  mutation(Types::MutationType)\nend\n\n\nThe schema declares that all the queries should go to Types::QueryType while\nmutations should go to Types::MutationType. We‚Äôre going to dig deeper into\nmutations in the second part of the series; the goal of this article is to learn\nhow to write and execute queries. Thus, let‚Äôs open the types/query_type.rb \nclass‚Äîit is an entry point for all the queries. What‚Äôs inside?\n\n# app/graphql/types/query_type.rb\nmodule Types\n  class QueryType < Types::BaseObject\n    # Add root-level fields here.\n    # They will be entry points for queries on your schema.\n\n    # TODO: remove me\n    field :test_field, String, null: false,\n      description: \"An example field added by the generator\"\n    def test_field\n      \"Hello World!\"\n    end\n  end\nend\n\n\nIt turns out that QueryType is just a regular type: it inherits from the \nTypes::BaseObject (which we will use as a base class for all types), and it has \nfield definitions‚Äìthe nodes of our data graph. The only thing that makes \nQueryType different is that GraphQL requires this type to exist (while mutation \nand subscription types are optional).\n\nHave noticed that the code above is actually a ‚Äúhello world‚Äù app? Before going\nfurther (and boring you with by the amount of code), we‚Äôd like to show you how\nto get this ‚Äúhello world‚Äù in your browser.\n\nLet‚Äôs see what has been added to the config/routes.rb file by the generator:\n\n# config/routes.rb\nRails.application.routes.draw do\n  mount GraphiQL::Rails::Engine, at: \"/graphiql\", graphql_path: \"/graphql\" if Rails.env.development?\n  post \"/graphql\", to: \"graphql#execute\"\nend\n\n\nMounting GraphiQL::Rails::Engine allows us to test our queries and mutations\nusing a web interface called GraphiQL [https://github.com/graphql/graphiql]. As\nwe discussed in the introduction, the schema can be inspected, and GraphiQL uses\nthis feature to build interactive documentation for us. It‚Äôs time to give it a\nshot!\n\n# Let's run a Rails web server\n$ rails s\n\n\nOpen up http://localhost:3000/graphiql in the browser:\n\nGraphiQL UI\n\nIn the left pane, you can type a query to execute, then click the ‚Äúplay‚Äù button\n(or hit Ctrl/Cmd+Enter) and get the response in the right pane. By clicking the\n‚ÄúDocs‚Äù link at the right top corner, you can explore your schema.\n\nLet‚Äôs take a look at our logs‚Äîwe want to know what happens when we click the\nexecute button.\n\nExecution logs\n\nGraphQL is transport-agnostic, but most implementations, including ruby-graphql,\nuse HTTP POST requests.\n\nRequests are sent to GraphqlController, which has also been added to the\napplication by the graphql gem generator.\n\nTake a look at the GraphqlController#execute action:\n\n# app/controllers/graphql_controller.rb\ndef execute\n  variables = ensure_hash(params[:variables])\n  query = params[:query]\n  operation_name = params[:operationName]\n  context = {\n    # Query context goes here, for example:\n    # current_user: current_user,\n  }\n  result = GraphqlSchema.execute(\n    query,\n    variables: variables,\n    context: context,\n    operation_name: operation_name\n  )\n  render json: result\nrescue StandardError => e\n  raise e unless Rails.env.development?\n\n  handle_error_in_development e\nend\n\n\nThis action calls the GraphqlSchema#execute method with the following\nparameters:\n\n * query and variables represent a query string and arguments sent by a client\n   respectively;\n * context is an arbitrary hash, which will be available during the query\n   execution everywhere;\n * operation_name picks a named operation from the incoming request to execute\n   (could be empty).\n\nAll the magic happens inside this method: it parses the query, detects all the\ntypes that should be used for building the response, and resolves all the\nrequested fields. The only thing we need to do is to define the types and\ndeclare how fields should be resolved.\n\nWhat‚Äôs in the Martian Library?\nLet‚Äôs move from ‚Äúhello world‚Äù to something real: remove the example contents\nfrom Types::QueryType and register a field called :items which will return all\nthe items from the library. We also need to add a resolver method for this field\n(the resolver method name must match the field name):\n\n# app/graphql/types/query_type.rb\nmodule Types\n  class QueryType < Types::BaseObject\n    field :items,\n          [Types::ItemType],\n          null: false,\n          description: \"Returns a list of items in the martian library\"\n\n    def items\n      Item.all\n    end\n  end\nend\n\n\nEach field definition contains a name, a result type, and options; :null is\nrequired and must be set to either true or false. We also define optional \n:description‚Äîit‚Äôs a good practice to add a human-readable message to a field: it\nwill be automatically added to documentation providing more context to\ndevelopers. The array notation for the result type, [Types::ItemType], means\nthat the field value must be an array and each element of this array must be\nrepresented using the Types::ItemType type.\n\nBut we haven‚Äôt defined ItemType yet, right? Hopefully, the graphql gem will give\nus a handy generator:\n\n$ rails g graphql:object item\n\n\nNow we can modify the newly created app/graphql/types/item_type.rb to our\nliking.\n\n# app/graphql/types/item_type.rb\nmodule Types\n  class ItemType < Types::BaseObject\n    field :id, ID, null: false\n    field :title, String, null: false\n    field :description, String, null: true\n    field :image_url, String, null: true\n  end\nend\n\n\nYou may use UUID as a primary key in your table if you are worried about\nexposing sequential IDs, but let‚Äôs go with the easy way now.\n\nAs you can see, we‚Äôre exposing three fields in ItemType:\n\n * non-nullable fields id and title\n * a nullable field description\n\nOur execution engine resolves fields using the following algorithm (slightly\nsimplified):\n\n * First, it looks for the method with the same name defined in the type class\n   itself (like we did earlier in the QueryType for items); we can access the\n   object being resolved using the object method.\n * If no such method defined, it tries to call the method with the same name on\n   the object itself.\n\nWe do not define any methods in our type class; thus, we assume that the\nunderlying implements all the fields‚Äô methods.\n\nGo back to http://localhost:3000/graphiql, execute the following query, and make\nsure that you get the list of all items in response:\n\n{\n  items {\n    id\n    title\n    description\n  }\n}\n\n\nSo far, we haven‚Äôt added any functionality that leverages the power of\ngraphs‚Äîour current graph‚Äôs depth is one. Let‚Äôs grow the graph by adding a\nnon-primitive node to ItemType, for example, a user field to represent the user\nwho created the item:\n\n# app/graphql/types/item_type.rb\nmodule Types\n  class ItemType < Types::BaseObject\n    # ...\n    field :user, Types::UserType, null: false\n  end\nend\n\n\nLet‚Äôs repeat the same generator spell to create a new type class:\n\n$ rails g graphql:object user\n\n\nThis time we also want to add a computed field‚Äîfull_name:\n\n# app/graphql/types/user_type.rb\nmodule Types\n  class UserType < Types::BaseObject\n    field :id, ID, null: false\n    field :email, String, null: false\n    field :full_name, String, null: false\n\n    def full_name\n      # `object` references the user instance\n      [object.first_name, object.last_name].compact.join(\" \")\n    end\n  end\nend\n\n\nLet‚Äôs transform our query to fetch users along with items:\n\n{\n  items {\n    id\n    title\n    user {\n      id\n      email\n    }\n  }\n}\n\n\nAt this point, we‚Äôre ready to move our attention from the backend side to the\nfrontend side. Let‚Äôs build a client for this API!\n\nConfiguring the frontend application\nIf you‚Äôre using Google Chrome, mind installing the Apollo extension\n[https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm]\n.\n\nAs we already mentioned, we recommend you install the Apollo\n[https://www.apollographql.com/docs/react/] framework for dealing with GraphQL\nclient-side.\n\nTo get the ball rolling, we need to install all the required dependencies:\n\n$ yarn add apollo-client apollo-cache-inmemory apollo-link-http apollo-link-error apollo-link graphql graphql-tag react-apollo\n\n\nWe didn‚Äôt include any package-adding types to JS (TypeScript\n[http://www.typescriptlang.org/] or Flow [https://flow.org/]) so as not to make\nthis tutorial too complicated. In practice, using typed JS with GraphQL makes a\nlot of sense since we already have a types system. For instance, apollo-codegen\n[https://github.com/apollographql/apollo-tooling] can generate type signatures\nautomatically.\n\nLet‚Äôs take a look at some of the installed packages:\n\n * We use graphql-tag to build our first queries.\n * apollo-client is a generic framework-agnostic package for performing and\n   caching GraphQL requests.\n * apollo-cache-inmemory is a storage implementation for Apollo cache.\n * react-apollo contains a set of React components for displaying data.\n * apollo-link and other links implement a middleware pattern for apollo-client \n   operations (you can find further details here\n   [https://www.apollographql.com/docs/link/overview.html]).\n\nNow we need to create an entry point for our frontend application. Remove \nhello_react.jsx from the packs folder and add index.js:\n\n$ rm app/javascript/packs/hello_react.jsx && touch app/javascript/packs/index.js\n\n\nFor the sake of debugging, it‚Äôs good enough to stay with the following content:\n\n// app/javascript/packs/index.js\nconsole.log('üëª');\n\n\nLet‚Äôs generate a controller to serve our frontend application:\n\n$ rails g controller Library index --skip-routes\n\n\nUpdate app/views/library/index.html.erb to contain the React root element and a\nlink to our pack:\n\n<!-- app/views/library/index.html.erb -->\n<div id=\"root\" />\n<%= javascript_pack_tag 'index' %>\n\n\nFinally, let‚Äôs register a new route in the config/routes.rb:\n\n# config/routes.rb\nroot 'library#index'\n\n\nRestart your Rails server and make sure you see the ghost in the browser\nconsole. Don‚Äôt be scared.\n\nConfiguring Apollo\nCreate a file for storing our application‚Äôs Apollo config:\n\n$ mkdir -p app/javascript/utils && touch app/javascript/utils/apollo.js\n\n\nIn this file we want to configure the two core entities of the Apollo\napplication, the client and the cache (or more precisely, the functions to\ncreate both):\n\n// app/javascript/utils/apollo.js\n\n// client\nimport { ApolloClient } from 'apollo-client';\n// cache\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n// links\nimport { HttpLink } from 'apollo-link-http';\nimport { onError } from 'apollo-link-error';\nimport { ApolloLink, Observable } from 'apollo-link';\nexport const createCache = () => {\n  const cache = new InMemoryCache();\n  if (process.env.NODE_ENV === 'development') {\n    window.secretVariableToStoreCache = cache;\n  }\n  return cache;\n};\n\n\nCaching is one of the most powerful features of Apollo. Sometimes it becomes\noverpowering, and you might prefer a more straightforward solution. In any case,\nit‚Äôs worth learning how it works. Find more details about how Apollo caching\nworks here [https://www.apollographql.com/docs/react/advanced/caching.html].\n\nLet‚Äôs take a second and look at how cache works.\n\nEach query response is put into the cache (the corresponding request is used to\ngenerate the cache key). Before making a request, apollo-client ensures that the\nresponse hasn‚Äôt been cached yet, and if it has been‚Äìthe request is not\nperformed. This behavior is configurable: for instance, we can turn off caching\nfor a particular request or ask the client to look for a cache entry of a\ndifferent query.\n\nOne important thing we need to know about the cache mechanism for this tutorial\nis that, by default, a cache key is a concatenation of the object id and \n__typename. Thus, fetching the same object twice would result only in one\nrequest.\n\nBack to coding. Since we use HTTP POST as a transport, we need to attach a\nproper CSRF token to every request to pass the forgery protection check\n[https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf] \nin the Rails app. We can grab it from meta[name=\"csrf-token\"] (which is\ngenerated by <%= csrf_meta_tags %>):\n\n// app/javascript/utils/apollo.js\n// ...\n// getToken from meta tags\nconst getToken = () =>\n  document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content');\nconst token = getToken();\nconst setTokenForOperation = async operation =>\n  operation.setContext({\n    headers: {\n      'X-CSRF-Token': token,\n    },\n  });\n// link with token\nconst createLinkWithToken = () =>\n  new ApolloLink(\n    (operation, forward) =>\n      new Observable(observer => {\n        let handle;\n        Promise.resolve(operation)\n          .then(setTokenForOperation)\n          .then(() => {\n            handle = forward(operation).subscribe({\n              next: observer.next.bind(observer),\n              error: observer.error.bind(observer),\n              complete: observer.complete.bind(observer),\n            });\n          })\n          .catch(observer.error.bind(observer));\n        return () => {\n          if (handle) handle.unsubscribe();\n        };\n      })\n  );\n\n\nLet‚Äôs look at how we can log errors:\n\n// app/javascript/utils/apollo.js\n//...\n// log erors\nconst logError = (error) => console.error(error);\n// create error link\nconst createErrorLink = () => onError(({ graphQLErrors, networkError, operation }) => {\n  if (graphQLErrors) {\n    logError('GraphQL - Error', {\n      errors: graphQLErrors,\n      operationName: operation.operationName,\n      variables: operation.variables,\n    });\n  }\n  if (networkError) {\n    logError('GraphQL - NetworkError', networkError);\n  }\n})\n\n\nIn production, it makes more sense to use an exception tracking service (e.g.,\nSentry or Honeybadger): just override the logError function to send errors to\nthe external system.\n\nWe‚Äôre almost there‚Äîlet‚Äôs tell the client about the endpoint for making queries:\n\n// app/javascript/utils/apollo.js\n//...\n// http link\nconst createHttpLink = () => new HttpLink({\n  uri: '/graphql',\n  credentials: 'include',\n})\n\n\nFinally, we‚Äôre ready to create an Apollo client instance:\n\n// app/javascript/utils/apollo.js\n//...\nexport const createClient = (cache, requestLink) => {\n  return new ApolloClient({\n    link: ApolloLink.from([\n      createErrorLink(),\n      createLinkWithToken(),\n      createHttpLink(),\n    ]),\n    cache,\n  });\n};\n\n\nThe very first query\nWe‚Äôre going to use a provider pattern\n[https://reactjs.org/docs/context.html#contextprovider] to pass the client\ninstances to React components:\n\n$ mkdir -p app/javascript/components/Provider && touch app/javascript/components/Provider/index.js\n\n\nIt‚Äôs the first time we are using an ApolloProvider component from the \nreact-apollo library:\n\n// app/javascript/components/Provider/index.js\nimport React from 'react';\nimport { ApolloProvider } from 'react-apollo';\nimport { createCache, createClient } from '../../utils/apollo';\n\nexport default ({ children }) => (\n  <ApolloProvider client={createClient(createCache())}>\n    {children}\n  </ApolloProvider>\n);\n\n\nLet‚Äôs change our index.js to use the newly created provider:\n\n// app/javascript/packs/index.js\nimport React from 'react';\nimport { render } from 'react-dom';\nimport Provider from '../components/Provider';\n\nrender(<Provider>üëª</Provider>, document.querySelector('#root'));\n\n\nIf you use Webpacker v3 you may need to import babel-polyfill to use all the\ncool JavaScript tricks like async/await. Don‚Äôt worry about the polyfill‚Äôs size; \nbabel-preset-env will remove everything you don‚Äôt need.\n\nLet‚Äôs create a Library component to display the list of items on the page:\n\n$ mkdir -p app/javascript/components/Library && touch app/javascript/components/Library/index.js\n\n\nWe‚Äôre going to use the Query component from react-apollo, which accepts the \nquery string as a property to fetch the data on mount:\n\n// app/javascript/components/Library/index.js\nimport React from 'react';\nimport { Query } from 'react-apollo';\nimport gql from 'graphql-tag';\n\nconst LibraryQuery = gql`\n  {\n    items {\n      id\n      title\n      user {\n        email\n      }\n    }\n  }\n`;\n\nexport default () => (\n  <Query query={LibraryQuery}>\n    {({ data, loading }) => (\n      <div>\n        {loading\n          ? 'loading...'\n          : data.items.map(({ title, id, user }) => (\n              <div key={id}>\n                <b>{title}</b> {user ? `added by ${user.email}` : null}\n              </div>\n            ))}\n      </div>\n    )}\n  </Query>\n);\n\n\nWe can access the loading state and loaded data through the corresponding \nloading and data properties (passed using a so-called render-props pattern\n[https://reactjs.org/docs/render-props.html]).\n\nDon‚Äôt forget to add the component to the main page:\n\n// app/javascript/packs/index.js\nimport React from 'react';\nimport { render } from 'react-dom';\nimport Provider from '../components/Provider';\nimport Library from '../components/Library';\n\nrender(\n  <Provider>\n    <Library />\n  </Provider>,\n  document.querySelector('#root')\n);\n\n\nIf you reload the page you should see the list of items with emails of users who\nadded them:\n\nList of¬†items with emails of¬†users\n\nCongratulations! You‚Äôve just made the very first step towards GraphQL happiness!\n\n‚Ä¶And the very first problem\nEverything seems to work fine, but let‚Äôs take a look at our server logs:\n\nN + 1\n\nThe SQL query SELECT * FROM users WHERE id = ? is executed four times, which\nmeans that we hit the famous N+1 problem‚Äìserver makes a query for each item in\nthe collection to get the corresponding user info.\n\nBefore fixing the problem, we need to make sure that it‚Äôs safe to make code\nmodifications without breaking anything‚Äîlet‚Äôs write some tests!\n\nWriting some specs\nSince we‚Äôre running on the edge, we need the upcoming version of the gem.\n\nNow it‚Äôs time to install and configure RSpec, or more precisely, the rspec-rails \ngem:\n\n# Add gem to the Gemfile\n$ bundle add rspec-rails --version=\"4.0.0.beta2\" --group=\"development,test\"\n# Generate the initial configuration\n$ rails generate rspec:install\n\n\nTo make it easier to generate data for tests let‚Äôs install factory_bot\n[https://github.com/thoughtbot/factory_bot]:\n\n$ bundle add factory_bot_rails --version=\"~> 5.0\" --group=\"development,test\"\n\n\nMake factory methods (create, build, etc.) globally visible in tests by adding \nconfig.include FactoryBot::Syntax::Methods to the rails_helper.rb.\n\nSince we created our models before adding Factory Bot, we should generate our\nfactories manually. Let‚Äôs create a single file, spec/factories.rb, for that:\n\n# spec/factories.rb\nFactoryBot.define do\n  factory :user do\n    # Use sequence to make sure that the value is unique\n    sequence(:email) { |n| \"user-#{n}@example.com\" }\n  end\n\n  factory :item do\n    sequence(:title) { |n| \"item-#{n}\" }\n    user\n  end\nend\n\n\nNow we are ready to write our first test. Let‚Äôs create a spec file for QueryType\n:\n\n$ mkdir -p spec/graphql/types\n$ touch spec/graphql/types/query_type_spec.rb\n\n\nThe simplest query test looks like this:\n\n# spec/graphql/types/query_type_spec.rb\nrequire \"rails_helper\"\n\nRSpec.describe Types::QueryType do\n  describe \"items\" do\n    let!(:items) { create_pair(:item) }\n\n    let(:query) do\n      %(query {\n        items {\n          title\n        }\n      })\n    end\n\n    subject(:result) do\n      MartianLibrarySchema.execute(query).as_json\n    end\n\n    it \"returns all items\" do\n      expect(result.dig(\"data\", \"items\")).to match_array(\n        items.map { |item| { \"title\" => item.title } }\n      )\n    end\n  end\nend\n\n\nTesting GraphQL might feel repetitive. Should it happen to you‚Äîconsider using\nfixtures and the fixturama [https://github.com/nepalez/fixturama] gem.\n\nFirst, we create a pair of items in our database. Then, we define the query\nunder test and the subject (result) by calling the GraphqlSchema.execute method.\nRemember, we had a similar line in the GraphqlController#execute?\n\nThis example is very straightforward: we‚Äôre not passing either variables or \ncontext to the execute call, though we definitely can do that if needed.\n\nNow we‚Äôre confident enough to fix ‚Äúthe bug‚Äù‚Äîthe N+1 problem!\n\nGraphQL vs. N+1 problem\nThe easiest way to avoid N+1 queries is to use eager loading\n[https://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations]\n. In our case, we need to preload users when making a query to fetch items in \nQueryType:\n\n# /app/graphql/types/query_type.rb\nmodule Types\n  class QueryType < Types::BaseObject\n    # ...\n\n    def items\n      Item.preload(:user)\n    end\n  end\nend\n\n\nThis solution can help in simple situations, but it‚Äôs not very efficient: the\nfollowing code preloads users even if the client does not need them, e.g.:\n\nitems {\n  title\n}\n\n\nLearn how to solve the N+1 problem using batch loading by example from the \n‚ÄúActive Storage meets GraphQL‚Äù\n[https://dev.to/evilmartians/active-storage-meets-graphql-pt-2-exposing-attachment-urls-2mdn] \npost in our dev.to blog.\n\nDiscussing other ways to solve the N+1 problem is worthy of a dedicated post and\nout of this tutorial‚Äôs scope.\nMost of the solutions fit the following two groups:\n\n * lazy eager loading (e.g., using the ar_lazy_preload\n   [https://github.com/DmitryTsepelev/ar_lazy_preload] gem)\n * batch loading (e.g., using the graphql-batch\n   [https://github.com/Shopify/graphql-batch] gem)\n\n\n--------------------------------------------------------------------------------\n\nThat‚Äôs all for today! We learned a lot about GraphQL, completed all the routine\nwork of configuring the backend and frontend applications, made the first query,\nand even found and fixed the first bug. And that‚Äôs just a tiny step (despite the\nsize of the article) in our journey. We‚Äôll come back shortly and unveil how to\nmanipulate data using GraphQL mutations and keep it up-to-date with\nsubscriptions. Stay tuned!","html":"<p>A hitchhiker‚Äôs guide to developing GraphQL applications with Rails on the backend side and React/Apollo on the frontend side. Follow this multi-part tutorial to learn both the basics and the advanced topics by example and feel the power of this modern technology.</p><p><a href=\"https://graphql.org/\">GraphQL</a> is one of those new shiny things we‚Äôve been seeing here, there and everywhere: <a href=\"https://dev.to/evilmartians/exposing-permissions-in-graphql-apis-with-action-policy-536a-temp-slug-455298?preview=5921586e85991fd5515f56b0ab8401d5fa1acb757e53ffc9c32c06243664d434f816c731482815c58f8a058def1cc2ae05638aacfce6c09d473010dc\">blog posts</a>, <a href=\"https://www.graphqlconf.org/\">conferences</a>, <a href=\"https://graphqlradio.com/\">podcasts</a>, maybe, even newspapers. It sounds like you should hurry up and start rewriting your application in GraphQL instead of REST as soon as possible, right? Not exactly. Remember: there is no silver bullet. It‚Äôs essential to understand the pros and cons of the technology before making a paradigm-shift decision.</p><p>Check out <a href=\"https://evilmartians.com/chronicles/graphql-on-rails-2-updating-the-data\">Part 2</a> and <a href=\"https://evilmartians.com/chronicles/graphql-on-rails-3-on-the-way-to-perfection\">Part 3</a></p><p>In this series, we‚Äôre going to walk you through a no-frills guide to the development of GraphQL applications, talking about not only its advantages but also its caveats and pitfalls (and, of course, the ways to deal with them).</p><h2 id=\"graphql-in-a-nutshell\">GraphQL in a nutshell</h2><p>There are a lot of other query languages, for instance, SQL and XPath.</p><p>According to the <a href=\"https://graphql.github.io/graphql-spec/\">specification</a>, GraphQL is a <em>query language</em> and <em>runtime</em> (or <em>execution engine</em>). Query language, <a href=\"https://en.wikipedia.org/wiki/Query_language\">by definition</a>, describes how to communicate with an information system. Runtime is responsible for fulfilling queries with data.</p><p>At the core of every GraphQL application lies a <a href=\"https://graphql.org/learn/schema/\"><em>schema</em></a>: it describes the underlying data in the form of a directed graph. The runtime must execute queries according to the schema (and some general rules from the specification). That means, every valid GraphQL server runs queries in the same manner and returns data in the same format for the same schema. In other words, the schema is everything clients should know about the API.</p><p>Here is an example of a simple GraphQL query:</p><pre><code>query getProduct($id: Int!) {\n  product(id: $id) {\n    id\n    title\n    manufacturer {\n      name\n    }\n  }\n}\n</code></pre><p>Let‚Äôs dissect it line by line:</p><ul><li>We define a named query (<code>getProduct</code> is the operation name) accepting a single argument (<code>$id</code>). The operation name is optional, but it helps readability and could be used by frontend for caching.</li><li>We ‚Äúselect‚Äù the <code>product</code> field from the ‚Äúroot‚Äù of the schema and pass the <code>$id</code> value as an argument.</li><li>We describe the fields we want to fetch: in this case, we want to get the <code>id</code> and <code>title</code> of the product as well as the <code>name</code> of the manufacturer.</li></ul><blockquote>Essentially, a query represents a sub-graph of the schema, which brings the first benefit of GraphQL‚Äîwe can fetch only this data we need and all we need at once, in a single query.</blockquote><p>Check out <a href=\"https://stackoverflow.com/questions/44564905/what-is-over-fetching-or-under-fetching\">this Stack Overflow post</a> to learn more about both overfetching and underfetching.</p><p>This way, we solve one of the common problems of the traditional REST APIs‚Äî<em>overfetching</em>.</p><p>Another noticeable feature of GraphQL schemas is they are <em>strongly</em> <em>typed</em>: both client and runtime ensure that the data passed is valid from the perspective of the application‚Äôs type system. For example, if someone mistakenly passes a string value as the <code>$id</code> to the query above, the client fails with the exception without even trying to perform a request.</p><p>There are plenty of tools to convert a schema into an interactive documentation website, standalone (e.g., <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a> or <a href=\"https://2fd.github.io/graphdoc\">graphdoc</a>) and framework-specific (e.g., <a href=\"https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\">Apollo DevTools</a>).</p><p>And the last but not least bonus is a <em>schema</em> <em>introspection</em>: clients can learn the API from the schema itself, without any additional documentation sources.</p><p>We‚Äôve just learned a bunch of theoretical aspects of GraphQL. Now it‚Äôs time to do some coding exercises to make sure you won‚Äôt forget everything tomorrow‚Äôs morning.</p><h2 id=\"what-are-we-going-to-build\">What are we going to build?</h2><p>During this series, we will be building an application representing a ‚ÄúMartian Library‚Äù‚Äîa personal online collection of movies, books, and other art objects related to the Red Planet.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://iron.fordeer.agency/content/images/2021/08/application-32576ed.png\" class=\"kg-image\" alt=\"The application we are going to build\" loading=\"lazy\" width=\"1600\" height=\"713\" srcset=\"https://iron.fordeer.agency/content/images/size/w600/2021/08/application-32576ed.png 600w, https://iron.fordeer.agency/content/images/size/w1000/2021/08/application-32576ed.png 1000w, https://iron.fordeer.agency/content/images/2021/08/application-32576ed.png 1600w\" sizes=\"(min-width: 720px) 720px\"><figcaption><p style=\"margin: 0px;\">The application we are going to&nbsp;build</p></figcaption></figure><p>For this tutorial, we‚Äôre going to use:</p><ul><li>Ruby 2.6 and Rails 6 (<a href=\"https://evilmartians.com/chronicles/rails-6-b-sides-and-rarities\">release candidate is already here</a>) for backend.</li><li>Node.js 9+, React 16.3+, and Apollo (client version 2+) for frontend (and make sure you have yarn installed according to the <a href=\"https://yarnpkg.com/en/docs/install#mac-stable\">instruction</a>).</li></ul><p>You can find the source code <a href=\"https://github.com/evilmartians/chronicles-gql-martian-library/tree/part-1\">here</a>‚Äîdon‚Äôt forget to run <code>bundle install &amp;&amp; yarn install</code> before the first run. <a href=\"https://github.com/evilmartians/chronicles-gql-martian-library\">Master</a> represents a current state of the project.</p><h2 id=\"setting-up-a-new-rails-project\">Setting up a new Rails project</h2><p>If at the time of reading this article Rails 6.0 hasn‚Äôt been released yet, you might need to install the release candidate first:</p><pre><code>$ gem install rails --pre\n$ rails -v\n=&gt; Rails 6.0.0.rc1\n</code></pre><p>Now we‚Äôre ready to run this unexpectedly long <code>rails new</code> command:</p><pre><code>$ rails new martian-library -d postgresql --skip-action-mailbox --skip-action-text --skip-spring --webpack=react -T --skip-turbolinks\n</code></pre><p>We prefer <em>okonomi</em> to <a href=\"https://dhh.dk/2012/rails-is-omakase.html\"><em>omakase</em></a>: skip frameworks and libraries we don‚Äôt need, choose PostgreSQL as our database, preconfigure Webpacker to use React, and skip tests (don‚Äôt worry‚Äìwe‚Äôll add RSpec soon).</p><p>Before you start, it‚Äôs strongly recommended that you disable all the unnecessary generators in the ¬†<code>config/application.rb</code>:</p><pre><code>config.generators do |g|\n  g.test_framework  false\n  g.stylesheets     false\n  g.javascripts     false\n  g.helper          false\n  g.channel         assets: false\nend\n</code></pre><h2 id=\"preparing-the-data-model\">Preparing the data model</h2><p>We need at least two models to start:</p><ul><li><code>Item</code> to describe any entity (book, movie, etc.) that we want to store in the library</li><li><code>User</code> to represent the application user who can manage items in the collection.</li></ul><p>Let‚Äôs generate them:</p><pre><code>$ rails g model User first_name last_name email\n$ rails g model Item title description:text image_url user:references\n</code></pre><p>Don‚Äôt forget to add the <code>has_many :items</code> association to <code>app/models/user.rb</code>:</p><pre><code># app/models/user.rb\nclass User &lt; ApplicationRecord\n  has_many :items, dependent: :destroy\nend\n</code></pre><p>Let‚Äôs add some pre-generated data to <code>db/seeds.rb</code>:</p><pre><code># db/seeds.rb\njohn = User.create!(\n  email: \"john.doe@example.com\",\n  first_name: \"John\",\n  last_name: \"Doe\"\n)\n\njane = User.create!(\n  email: \"jane.doe@example.com\",\n  first_name: \"Jane\",\n  last_name: \"Doe\"\n)\n\nItem.create!(\n  [\n    {\n      title: \"Martian Chronicles\",\n      description: \"Cult book by Ray Bradbury\",\n      user: john,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/4/45/The-Martian-Chronicles.jpg\"\n    },\n    {\n      title: \"The Martian\",\n      description: \"Novel by Andy Weir about an astronaut stranded on Mars trying to survive\",\n      user: john,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/c/c3/The_Martian_2014.jpg\"\n    },\n    {\n      title: \"Doom\",\n      description: \"A group of Marines is sent to the red planet via an ancient \" \\\n                   \"Martian portal called the Ark to deal with an outbreak of a mutagenic virus\",\n      user: jane,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/5/57/Doom_cover_art.jpg\"\n    },\n    {\n      title: \"Mars Attacks!\",\n      description: \"Earth is invaded by Martians with unbeatable weapons and a cruel sense of humor\",\n      user: jane,\n      image_url: \"https://upload.wikimedia.org/wikipedia/en/b/bd/Mars_attacks_ver1.jpg\"\n    }\n  ]\n)\n</code></pre><p>Finally, we‚Äôre ready to initialize our database:</p><pre><code>$ rails db:create db:migrate db:seed\n</code></pre><p>Now that we‚Äôve put some information into our system, let‚Äôs add a way to access it!</p><h2 id=\"adding-a-graphql-endpoint\">Adding a GraphQL endpoint</h2><p>For crafting our GraphQL API, we will use the <a href=\"https://github.com/rmosolgo/graphql-ruby\">graphql-ruby</a> gem:</p><pre><code># First, add it to the Gemfile\n$ bundle add graphql --version=\"~&gt; 1.9\"\n# Then, run the generator\n$ rails generate graphql:install\n</code></pre><p>You might be surprised by the number of files a minimal <code>graphql-ruby</code> application requires: this boilerplate is the price we pay for all the goodies we described above.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/generator-d6a5280.png\" class=\"kg-image\" alt=\"The result of executing generator\" loading=\"lazy\"><figcaption><p style=\"margin: 0px;\">The result of&nbsp;executing <code style=\"font-family: &quot;Fira Code&quot;, &quot;Lucida Console&quot;, Monaco, monospace; font-size: 1em; color: rgb(191, 108, 53); font-feature-settings: &quot;calt&quot;; text-rendering: optimizelegibility; white-space: pre-wrap;\">graphql:install</code> generator</p></figcaption></figure><p>First of all, let‚Äôs take a look at the schema, <code>martian_library_schema.rb</code>:</p><pre><code># app/graphql/martian_library_schema.rb\nclass MartianLibrarySchema &lt; GraphQL::Schema\n  query(Types::QueryType)\n  mutation(Types::MutationType)\nend\n</code></pre><p>The schema declares that all the queries should go to <code>Types::QueryType</code> while mutations should go to <code>Types::MutationType</code>. We‚Äôre going to dig deeper into mutations in the second part of the series; the goal of this article is to learn how to write and execute queries. Thus, let‚Äôs open the <code>types/query_type.rb</code> class‚Äîit is an entry point for all the queries. What‚Äôs inside?</p><pre><code># app/graphql/types/query_type.rb\nmodule Types\n  class QueryType &lt; Types::BaseObject\n    # Add root-level fields here.\n    # They will be entry points for queries on your schema.\n\n    # TODO: remove me\n    field :test_field, String, null: false,\n      description: \"An example field added by the generator\"\n    def test_field\n      \"Hello World!\"\n    end\n  end\nend\n</code></pre><p>It turns out that <code>QueryType</code> is just a regular type: it inherits from the <code>Types::BaseObject</code> (which we will use as a base class for all types), and it has <em>field</em> definitions‚Äìthe nodes of our data graph. The only thing that makes <code>QueryType</code> different is that GraphQL requires this type to exist (while <em>mutation</em> and <em>subscription</em> types are optional).</p><p>Have noticed that the code above is actually a ‚Äúhello world‚Äù app? Before going further (and boring you with by the amount of code), we‚Äôd like to show you how to get this ‚Äúhello world‚Äù in your browser.</p><p>Let‚Äôs see what has been added to the <code>config/routes.rb</code> file by the generator:</p><pre><code># config/routes.rb\nRails.application.routes.draw do\n  mount GraphiQL::Rails::Engine, at: \"/graphiql\", graphql_path: \"/graphql\" if Rails.env.development?\n  post \"/graphql\", to: \"graphql#execute\"\nend\n</code></pre><p>Mounting <code>GraphiQL::Rails::Engine</code> allows us to test our queries and mutations using a web interface called <a href=\"https://github.com/graphql/graphiql\">GraphiQL</a>. As we discussed in the introduction, the schema can be inspected, and GraphiQL uses this feature to build interactive documentation for us. It‚Äôs time to give it a shot!</p><pre><code># Let's run a Rails web server\n$ rails s\n</code></pre><p>Open up <a href=\"http://localhost:3000/graphiql\">http://localhost:3000/graphiql</a> in the browser:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/graphiql-4633e9d.png\" class=\"kg-image\" alt=\"GraphiQL UI\" loading=\"lazy\"><figcaption><p style=\"margin: 0px;\">GraphiQL UI</p></figcaption></figure><p>In the left pane, you can type a query to execute, then click the ‚Äúplay‚Äù button (or hit <em>Ctrl/Cmd+Enter</em>) and get the response in the right pane. By clicking the ‚ÄúDocs‚Äù link at the right top corner, you can explore your schema.</p><p>Let‚Äôs take a look at our logs‚Äîwe want to know what happens when we click the execute button.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/execute_log-e654371.png\" class=\"kg-image\" alt=\"Execution logs\" loading=\"lazy\"><figcaption><p style=\"margin: 0px;\">Execution logs</p></figcaption></figure><p>GraphQL is transport-agnostic, but most implementations, including <code>ruby-graphql</code>, use HTTP POST requests.</p><p>Requests are sent to <code>GraphqlController</code>, which has also been added to the application by the <code>graphql</code> gem generator.</p><p>Take a look at the <code>GraphqlController#execute</code> action:</p><pre><code># app/controllers/graphql_controller.rb\ndef execute\n  variables = ensure_hash(params[:variables])\n  query = params[:query]\n  operation_name = params[:operationName]\n  context = {\n    # Query context goes here, for example:\n    # current_user: current_user,\n  }\n  result = GraphqlSchema.execute(\n    query,\n    variables: variables,\n    context: context,\n    operation_name: operation_name\n  )\n  render json: result\nrescue StandardError =&gt; e\n  raise e unless Rails.env.development?\n\n  handle_error_in_development e\nend\n</code></pre><p>This action calls the <code>GraphqlSchema#execute</code> method with the following parameters:</p><ul><li><code>query</code> and <code>variables</code> represent a query string and arguments sent by a client respectively;</li><li><code>context</code> is an arbitrary hash, which will be available during the query execution everywhere;</li><li><code>operation_name</code> picks a named operation from the incoming request to execute (could be empty).</li></ul><p>All the magic happens inside this method: it parses the query, detects all the types that should be used for building the response, and resolves all the requested fields. The only thing we need to do is to define the types and declare how fields should be resolved.</p><h2 id=\"what%E2%80%99s-in-the-martian-library\">What‚Äôs in the Martian Library?</h2><p>Let‚Äôs move from ‚Äúhello world‚Äù to something real: remove the example contents from <code>Types::QueryType</code> and register a field called <code>:items</code> which will return all the items from the library. We also need to add a resolver method for this field (the resolver method name must match the field name):</p><pre><code># app/graphql/types/query_type.rb\nmodule Types\n  class QueryType &lt; Types::BaseObject\n    field :items,\n          [Types::ItemType],\n          null: false,\n          description: \"Returns a list of items in the martian library\"\n\n    def items\n      Item.all\n    end\n  end\nend\n</code></pre><p>Each field definition contains a name, a result type, and options; <code>:null</code> is required and must be set to either <code>true</code> or <code>false</code>. We also define optional <code>:description</code>‚Äîit‚Äôs a good practice to add a human-readable message to a field: it will be automatically added to documentation providing more context to developers. The array notation for the result type, <code>[Types::ItemType]</code>, means that the field value must be an array and each element of this array must be represented using the <code>Types::ItemType</code> type.</p><p>But we haven‚Äôt defined <code>ItemType</code> yet, right? Hopefully, the <code>graphql</code> gem will give us a handy generator:</p><pre><code>$ rails g graphql:object item\n</code></pre><p>Now we can modify the newly created <code>app/graphql/types/item_type.rb</code> to our liking.</p><pre><code># app/graphql/types/item_type.rb\nmodule Types\n  class ItemType &lt; Types::BaseObject\n    field :id, ID, null: false\n    field :title, String, null: false\n    field :description, String, null: true\n    field :image_url, String, null: true\n  end\nend\n</code></pre><p>You may use UUID as a primary key in your table if you are worried about exposing sequential IDs, but let‚Äôs go with the easy way now.</p><p>As you can see, we‚Äôre exposing three fields in <code>ItemType</code>:</p><ul><li>non-nullable fields <code>id</code> and <code>title</code></li><li>a nullable field <code>description</code></li></ul><p>Our execution engine resolves fields using the following algorithm (slightly simplified):</p><ul><li>First, it looks for the method with the same name defined in the type class itself (like we did earlier in the <code>QueryType</code> for <code>items</code>); we can access the object being resolved using the <code>object</code> method.</li><li>If no such method defined, it tries to call the method with the same name on the <code>object</code> itself.</li></ul><p>We do not define any methods in our type class; thus, we assume that the underlying implements all the fields‚Äô methods.</p><p>Go back to <a href=\"http://localhost:3000/graphiql\">http://localhost:3000/graphiql</a>, execute the following query, and make sure that you get the list of all items in response:</p><pre><code>{\n  items {\n    id\n    title\n    description\n  }\n}\n</code></pre><p>So far, we haven‚Äôt added any functionality that leverages the power of graphs‚Äîour current graph‚Äôs depth is one. Let‚Äôs grow the graph by adding a non-primitive node to <code>ItemType</code>, for example, a <code>user</code> field to represent the user who created the item:</p><pre><code># app/graphql/types/item_type.rb\nmodule Types\n  class ItemType &lt; Types::BaseObject\n    # ...\n    field :user, Types::UserType, null: false\n  end\nend\n</code></pre><p>Let‚Äôs repeat the same generator spell to create a new type class:</p><pre><code>$ rails g graphql:object user\n</code></pre><p>This time we also want to add a computed field‚Äî<code>full_name</code>:</p><pre><code># app/graphql/types/user_type.rb\nmodule Types\n  class UserType &lt; Types::BaseObject\n    field :id, ID, null: false\n    field :email, String, null: false\n    field :full_name, String, null: false\n\n    def full_name\n      # `object` references the user instance\n      [object.first_name, object.last_name].compact.join(\" \")\n    end\n  end\nend\n</code></pre><p>Let‚Äôs transform our query to fetch users along with items:</p><pre><code>{\n  items {\n    id\n    title\n    user {\n      id\n      email\n    }\n  }\n}\n</code></pre><p>At this point, we‚Äôre ready to move our attention from the backend side to the frontend side. Let‚Äôs build a client for this API!</p><h2 id=\"configuring-the-frontend-application\">Configuring the frontend application</h2><p>If you‚Äôre using Google Chrome, mind installing the Apollo <a href=\"https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\">extension</a>.</p><p>As we already mentioned, we recommend you install the <a href=\"https://www.apollographql.com/docs/react/\">Apollo</a> framework for dealing with GraphQL client-side.</p><p>To get the ball rolling, we need to install all the required dependencies:</p><pre><code>$ yarn add apollo-client apollo-cache-inmemory apollo-link-http apollo-link-error apollo-link graphql graphql-tag react-apollo\n</code></pre><p>We didn‚Äôt include any package-adding types to JS (<a href=\"http://www.typescriptlang.org/\">TypeScript</a> or <a href=\"https://flow.org/\">Flow</a>) so as not to make this tutorial too complicated. In practice, using typed JS with GraphQL makes a lot of sense since we already have a types system. For instance, <a href=\"https://github.com/apollographql/apollo-tooling\">apollo-codegen</a> can generate type signatures automatically.</p><p>Let‚Äôs take a look at some of the installed packages:</p><ul><li>We use <code>graphql-tag</code> to build our first queries.</li><li><code>apollo-client</code> is a generic framework-agnostic package for performing and caching GraphQL requests.</li><li><code>apollo-cache-inmemory</code> is a storage implementation for Apollo cache.</li><li><code>react-apollo</code> contains a set of React components for displaying data.</li><li><code>apollo-link</code> and other <em>links</em> implement a middleware pattern for <code>apollo-client</code> operations (you can find further details <a href=\"https://www.apollographql.com/docs/link/overview.html\">here</a>).</li></ul><p>Now we need to create an entry point for our frontend application. Remove <code>hello_react.jsx</code> from the <code>packs</code> folder and add <code>index.js</code>:</p><pre><code>$ rm app/javascript/packs/hello_react.jsx &amp;&amp; touch app/javascript/packs/index.js\n</code></pre><p>For the sake of debugging, it‚Äôs good enough to stay with the following content:</p><pre><code>// app/javascript/packs/index.js\nconsole.log('üëª');\n</code></pre><p>Let‚Äôs generate a controller to serve our frontend application:</p><pre><code>$ rails g controller Library index --skip-routes\n</code></pre><p>Update <code>app/views/library/index.html.erb</code> to contain the React root element and a link to our <em>pack</em>:</p><pre><code>&lt;!-- app/views/library/index.html.erb --&gt;\n&lt;div id=\"root\" /&gt;\n&lt;%= javascript_pack_tag 'index' %&gt;\n</code></pre><p>Finally, let‚Äôs register a new route in the <code>config/routes.rb</code>:</p><pre><code># config/routes.rb\nroot 'library#index'\n</code></pre><p>Restart your Rails server and make sure you see the ghost in the browser console. Don‚Äôt be scared.</p><h2 id=\"configuring-apollo\">Configuring Apollo</h2><p>Create a file for storing our application‚Äôs Apollo config:</p><pre><code>$ mkdir -p app/javascript/utils &amp;&amp; touch app/javascript/utils/apollo.js\n</code></pre><p>In this file we want to configure the two core entities of the Apollo application, the client and the cache (or more precisely, the functions to create both):</p><pre><code>// app/javascript/utils/apollo.js\n\n// client\nimport { ApolloClient } from 'apollo-client';\n// cache\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n// links\nimport { HttpLink } from 'apollo-link-http';\nimport { onError } from 'apollo-link-error';\nimport { ApolloLink, Observable } from 'apollo-link';\nexport const createCache = () =&gt; {\n  const cache = new InMemoryCache();\n  if (process.env.NODE_ENV === 'development') {\n    window.secretVariableToStoreCache = cache;\n  }\n  return cache;\n};\n</code></pre><p>Caching is one of the most powerful features of Apollo. Sometimes it becomes overpowering, and you might prefer a more straightforward solution. In any case, it‚Äôs worth learning how it works. Find more details about how Apollo caching works <a href=\"https://www.apollographql.com/docs/react/advanced/caching.html\">here</a>.</p><p>Let‚Äôs take a second and look at how cache works.</p><p>Each query response is put into the cache (the corresponding request is used to generate the cache key). Before making a request, <code>apollo-client</code> ensures that the response hasn‚Äôt been cached yet, and if it has been‚Äìthe request is not performed. This behavior is configurable: for instance, we can turn off caching for a particular request or ask the client to look for a cache entry of a different query.</p><p>One important thing we need to know about the cache mechanism for this tutorial is that, by default, a cache key is a concatenation of the object <code>id</code> and <code>__typename</code>. Thus, fetching the same object twice would result only in one request.</p><p>Back to coding. Since we use HTTP POST as a transport, we need to attach a proper CSRF token to every request to pass the <a href=\"https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf\">forgery protection check</a> in the Rails app. We can grab it from <code>meta[name=\"csrf-token\"]</code> (which is generated by <code>&lt;%= csrf_meta_tags %&gt;</code>):</p><pre><code>// app/javascript/utils/apollo.js\n// ...\n// getToken from meta tags\nconst getToken = () =&gt;\n  document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content');\nconst token = getToken();\nconst setTokenForOperation = async operation =&gt;\n  operation.setContext({\n    headers: {\n      'X-CSRF-Token': token,\n    },\n  });\n// link with token\nconst createLinkWithToken = () =&gt;\n  new ApolloLink(\n    (operation, forward) =&gt;\n      new Observable(observer =&gt; {\n        let handle;\n        Promise.resolve(operation)\n          .then(setTokenForOperation)\n          .then(() =&gt; {\n            handle = forward(operation).subscribe({\n              next: observer.next.bind(observer),\n              error: observer.error.bind(observer),\n              complete: observer.complete.bind(observer),\n            });\n          })\n          .catch(observer.error.bind(observer));\n        return () =&gt; {\n          if (handle) handle.unsubscribe();\n        };\n      })\n  );\n</code></pre><p>Let‚Äôs look at how we can log errors:</p><pre><code>// app/javascript/utils/apollo.js\n//...\n// log erors\nconst logError = (error) =&gt; console.error(error);\n// create error link\nconst createErrorLink = () =&gt; onError(({ graphQLErrors, networkError, operation }) =&gt; {\n  if (graphQLErrors) {\n    logError('GraphQL - Error', {\n      errors: graphQLErrors,\n      operationName: operation.operationName,\n      variables: operation.variables,\n    });\n  }\n  if (networkError) {\n    logError('GraphQL - NetworkError', networkError);\n  }\n})\n</code></pre><p>In production, it makes more sense to use an exception tracking service (e.g., Sentry or Honeybadger): just override the <code>logError</code> function to send errors to the external system.</p><p>We‚Äôre almost there‚Äîlet‚Äôs tell the client about the endpoint for making queries:</p><pre><code>// app/javascript/utils/apollo.js\n//...\n// http link\nconst createHttpLink = () =&gt; new HttpLink({\n  uri: '/graphql',\n  credentials: 'include',\n})\n</code></pre><p>Finally, we‚Äôre ready to create an Apollo client instance:</p><pre><code>// app/javascript/utils/apollo.js\n//...\nexport const createClient = (cache, requestLink) =&gt; {\n  return new ApolloClient({\n    link: ApolloLink.from([\n      createErrorLink(),\n      createLinkWithToken(),\n      createHttpLink(),\n    ]),\n    cache,\n  });\n};\n</code></pre><h2 id=\"the-very-first-query\">The very first query</h2><p>We‚Äôre going to use a <a href=\"https://reactjs.org/docs/context.html#contextprovider\">provider pattern</a> to pass the client instances to React components:</p><pre><code>$ mkdir -p app/javascript/components/Provider &amp;&amp; touch app/javascript/components/Provider/index.js\n</code></pre><p>It‚Äôs the first time we are using an <code>ApolloProvider</code> component from the <code>react-apollo</code> library:</p><pre><code>// app/javascript/components/Provider/index.js\nimport React from 'react';\nimport { ApolloProvider } from 'react-apollo';\nimport { createCache, createClient } from '../../utils/apollo';\n\nexport default ({ children }) =&gt; (\n  &lt;ApolloProvider client={createClient(createCache())}&gt;\n    {children}\n  &lt;/ApolloProvider&gt;\n);\n</code></pre><p>Let‚Äôs change our <code>index.js</code> to use the newly created provider:</p><pre><code>// app/javascript/packs/index.js\nimport React from 'react';\nimport { render } from 'react-dom';\nimport Provider from '../components/Provider';\n\nrender(&lt;Provider&gt;üëª&lt;/Provider&gt;, document.querySelector('#root'));\n</code></pre><p>If you use <code>Webpacker v3</code> you may need to import <code>babel-polyfill</code> to use all the cool JavaScript tricks like async/await. Don‚Äôt worry about the polyfill‚Äôs size; <code>babel-preset-env</code> will remove everything you don‚Äôt need.</p><p>Let‚Äôs create a <code>Library</code> component to display the list of items on the page:</p><pre><code>$ mkdir -p app/javascript/components/Library &amp;&amp; touch app/javascript/components/Library/index.js\n</code></pre><p>We‚Äôre going to use the <code>Query</code> component from <code>react-apollo</code>, which accepts the <code>query</code> string as a property to fetch the data on mount:</p><pre><code>// app/javascript/components/Library/index.js\nimport React from 'react';\nimport { Query } from 'react-apollo';\nimport gql from 'graphql-tag';\n\nconst LibraryQuery = gql`\n  {\n    items {\n      id\n      title\n      user {\n        email\n      }\n    }\n  }\n`;\n\nexport default () =&gt; (\n  &lt;Query query={LibraryQuery}&gt;\n    {({ data, loading }) =&gt; (\n      &lt;div&gt;\n        {loading\n          ? 'loading...'\n          : data.items.map(({ title, id, user }) =&gt; (\n              &lt;div key={id}&gt;\n                &lt;b&gt;{title}&lt;/b&gt; {user ? `added by ${user.email}` : null}\n              &lt;/div&gt;\n            ))}\n      &lt;/div&gt;\n    )}\n  &lt;/Query&gt;\n);\n</code></pre><p>We can access the loading state and loaded data through the corresponding <code>loading</code> and <code>data</code> properties (passed using a so-called <a href=\"https://reactjs.org/docs/render-props.html\">render-props pattern</a>).</p><p>Don‚Äôt forget to add the component to the main page:</p><pre><code>// app/javascript/packs/index.js\nimport React from 'react';\nimport { render } from 'react-dom';\nimport Provider from '../components/Provider';\nimport Library from '../components/Library';\n\nrender(\n  &lt;Provider&gt;\n    &lt;Library /&gt;\n  &lt;/Provider&gt;,\n  document.querySelector('#root')\n);\n</code></pre><p>If you reload the page you should see the list of items with emails of users who added them:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/items-b791b9f.png\" class=\"kg-image\" alt=\"List of items with emails of users\" loading=\"lazy\"><figcaption><p style=\"margin: 0px;\">List of&nbsp;items with emails of&nbsp;users</p></figcaption></figure><p>Congratulations! You‚Äôve just made the very first step towards GraphQL happiness!</p><h2 id=\"%E2%80%A6and-the-very-first-problem\">‚Ä¶And the very first problem</h2><p>Everything seems to work fine, but let‚Äôs take a look at our server logs:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/n_plus_one-77d1121.png\" class=\"kg-image\" alt=\"N + 1\" loading=\"lazy\"><figcaption><p style=\"margin: 0px;\">N + 1</p></figcaption></figure><p>The SQL query <code>SELECT * FROM users WHERE id = ?</code> is executed <strong>four times</strong>, which means that we hit the famous <em>N+1 problem</em>‚Äìserver makes a query for each item in the collection to get the corresponding user info.</p><p>Before fixing the problem, we need to make sure that it‚Äôs safe to make code modifications without breaking anything‚Äîlet‚Äôs write some tests!</p><h2 id=\"writing-some-specs\">Writing some specs</h2><p>Since we‚Äôre running on the edge, we need the upcoming version of the gem.</p><p>Now it‚Äôs time to install and configure RSpec, or more precisely, the <code>rspec-rails</code> gem:</p><pre><code># Add gem to the Gemfile\n$ bundle add rspec-rails --version=\"4.0.0.beta2\" --group=\"development,test\"\n# Generate the initial configuration\n$ rails generate rspec:install\n</code></pre><p>To make it easier to generate data for tests let‚Äôs install <a href=\"https://github.com/thoughtbot/factory_bot\">factory_bot</a>:</p><pre><code>$ bundle add factory_bot_rails --version=\"~&gt; 5.0\" --group=\"development,test\"\n</code></pre><p>Make factory methods (<code>create</code>, <code>build</code>, etc.) globally visible in tests by adding <code>config.include FactoryBot::Syntax::Methods</code> to the <code>rails_helper.rb</code>.</p><p>Since we created our models before adding Factory Bot, we should generate our factories manually. Let‚Äôs create a single file, <code>spec/factories.rb</code>, for that:</p><pre><code># spec/factories.rb\nFactoryBot.define do\n  factory :user do\n    # Use sequence to make sure that the value is unique\n    sequence(:email) { |n| \"user-#{n}@example.com\" }\n  end\n\n  factory :item do\n    sequence(:title) { |n| \"item-#{n}\" }\n    user\n  end\nend\n</code></pre><p>Now we are ready to write our first test. Let‚Äôs create a spec file for <code>QueryType</code>:</p><pre><code>$ mkdir -p spec/graphql/types\n$ touch spec/graphql/types/query_type_spec.rb\n</code></pre><p>The simplest query test looks like this:</p><pre><code># spec/graphql/types/query_type_spec.rb\nrequire \"rails_helper\"\n\nRSpec.describe Types::QueryType do\n  describe \"items\" do\n    let!(:items) { create_pair(:item) }\n\n    let(:query) do\n      %(query {\n        items {\n          title\n        }\n      })\n    end\n\n    subject(:result) do\n      MartianLibrarySchema.execute(query).as_json\n    end\n\n    it \"returns all items\" do\n      expect(result.dig(\"data\", \"items\")).to match_array(\n        items.map { |item| { \"title\" =&gt; item.title } }\n      )\n    end\n  end\nend\n</code></pre><p>Testing GraphQL might feel repetitive. Should it happen to you‚Äîconsider using fixtures and the <a href=\"https://github.com/nepalez/fixturama\">fixturama</a> gem.</p><p>First, we create a pair of items in our database. Then, we define the query under test and the subject (<code>result</code>) by calling the <code>GraphqlSchema.execute</code> method. Remember, we had a similar line in the <code>GraphqlController#execute</code>?</p><p>This example is very straightforward: we‚Äôre not passing either <code>variables</code> or <code>context</code> to the <code>execute</code> call, though we definitely can do that if needed.</p><p>Now we‚Äôre confident enough to fix ‚Äúthe bug‚Äù‚Äîthe N+1 problem!</p><h2 id=\"graphql-vs-n1-problem\">GraphQL vs. N+1 problem</h2><p>The easiest way to avoid N+1 queries is to use <a href=\"https://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations\">eager loading</a>. In our case, we need to preload users when making a query to fetch items in <code>QueryType</code>:</p><pre><code># /app/graphql/types/query_type.rb\nmodule Types\n  class QueryType &lt; Types::BaseObject\n    # ...\n\n    def items\n      Item.preload(:user)\n    end\n  end\nend\n</code></pre><p>This solution can help in simple situations, but it‚Äôs not very efficient: the following code preloads users even if the client does not need them, e.g.:</p><pre><code>items {\n  title\n}\n</code></pre><p>Learn how to solve the N+1 problem using batch loading by example from the <a href=\"https://dev.to/evilmartians/active-storage-meets-graphql-pt-2-exposing-attachment-urls-2mdn\">‚ÄúActive Storage meets GraphQL‚Äù</a> post in our dev.to blog.</p><p>Discussing other ways to solve the N+1 problem is worthy of a dedicated post and out of this tutorial‚Äôs scope.<br>Most of the solutions fit the following two groups:</p><ul><li>lazy eager loading (e.g., using the <a href=\"https://github.com/DmitryTsepelev/ar_lazy_preload\">ar_lazy_preload</a> gem)</li><li>batch loading (e.g., using the <a href=\"https://github.com/Shopify/graphql-batch\">graphql-batch</a> gem)</li></ul><hr><p>That‚Äôs all for today! We learned a lot about GraphQL, completed all the routine work of configuring the backend and frontend applications, made the first query, and even found and fixed the first bug. And that‚Äôs just a tiny step (despite the size of the article) in our journey. We‚Äôll come back shortly and unveil how to manipulate data using GraphQL mutations and keep it up-to-date with subscriptions. Stay tuned!</p>","url":"https://iron.fordeer.agency/graphql-on-rails-from-zero-to-the-first-query/","canonical_url":null,"uuid":"89206142-5fb7-419a-ac5d-ffe96222b0f2","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"612e07af894d3804d9ca6d95","reading_time":17}},{"node":{"id":"Ghost__Post__612df6616c623f9319ddfd28","title":"Building your audience with subscriber signups","slug":"portal","featured":false,"feature_image":"https://static.ghost.org/v4.0.0/images/creating-a-custom-theme.png","excerpt":"How Ghost allows you to turn anonymous readers into an audience of active subscribers, so you know what's working and what isn't.","custom_excerpt":"How Ghost allows you to turn anonymous readers into an audience of active subscribers, so you know what's working and what isn't.","visibility":"public","created_at_pretty":"31 August, 2021","published_at_pretty":"31 August, 2021","updated_at_pretty":"31 August, 2021","created_at":"2021-08-31T16:29:05.000+07:00","published_at":"2021-08-31T16:29:07.000+07:00","updated_at":"2021-08-31T16:29:05.000+07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"}],"primary_author":{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"},"primary_tag":{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"What sets Ghost apart from other products is that you can publish content and\ngrow your audience using the same platform. Rather than just endlessly posting\nand hoping someone is listening, you can track real signups against your work\nand have them subscribe to be notified of future posts. The feature that makes\nall this possible is called Portal.\n\nPortal is an embedded interface for your audience to sign up to your site. It\nworks on every Ghost site, with every theme, and for any type of publisher. \n\nYou can customize the design, content and settings of Portal to suit your site,\nwhether you just want people to sign up to your newsletter ‚Äî or you're running a\nfull premium publication with user sign-ins and private content.\n\nOnce people sign up to your site, they'll receive an email confirmation with a\nlink to click. The link acts as an automatic sign-in, so subscribers will be\nautomatically signed-in to your site when they click on it. There are a couple\nof interesting angles to this:\n\nBecause subscribers are automatically able to sign in and out of your site as\nregistered members: You can (optionally) restrict access to posts and pages\ndepending on whether people are signed-in or not. So if you want to publish some\nposts for free, but keep some really great stuff for members-only, this can be a\ngreat draw to encourage people to sign up!\n\nGhost members sign in using email authentication links, so there are no\npasswords for people to set or forget. You can turn any list of email\nsubscribers into a database of registered members who can sign in to your site.\nLike magic.\n\nPortal makes all of this possible, and it appears by default as a floating\nbutton in the bottom-right corner of your site. When people are logged out,\nclicking it will open a sign-up/sign-in window. When members are logged in,\nclicking the Portal button will open the account menu where they can edit their\nname, email, and subscription settings.\n\nThe floating Portal button is completely optional. If you prefer, you can add\nmanual links to your content, navigation, or theme to trigger it instead.\n\nLike this! Sign up here\n\n\n--------------------------------------------------------------------------------\n\nAs you start to grow your registered audience, you'll be able to get a sense of\nwho you're publishing for and where those people are coming from. Best of all:\nYou'll have a straightforward, reliable way to connect with people who enjoy\nyour work.\n\nSocial networks go in and out of fashion all the time. Email addresses are\ntimeless.\n\nGrowing your audience is valuable no matter what type of site you run, but if\nyour content is your business, then you might also be interested in setting up\npremium subscriptions [https://iron.fordeer.agency/sell/].","html":"<p>What sets Ghost apart from other products is that you can publish content and grow your audience using the same platform. Rather than just endlessly posting and hoping someone is listening, you can track real signups against your work and have them subscribe to be notified of future posts. The feature that makes all this possible is called <em>Portal</em>.</p><p>Portal is an embedded interface for your audience to sign up to your site. It works on every Ghost site, with every theme, and for any type of publisher. </p><p>You can customize the design, content and settings of Portal to suit your site, whether you just want people to sign up to your newsletter ‚Äî or you're running a full premium publication with user sign-ins and private content.</p><figure class=\"kg-card kg-image-card kg-width-wide\"><img src=\"https://static.ghost.org/v4.0.0/images/portalsettings.png\" class=\"kg-image\" alt loading=\"lazy\" width=\"2924\" height=\"1810\"></figure><p>Once people sign up to your site, they'll receive an email confirmation with a link to click. The link acts as an automatic sign-in, so subscribers will be automatically signed-in to your site when they click on it. There are a couple of interesting angles to this:</p><p>Because subscribers are automatically able to sign in and out of your site as registered members: You can (optionally) restrict access to posts and pages depending on whether people are signed-in or not. So if you want to publish some posts for free, but keep some really great stuff for members-only, this can be a great draw to encourage people to sign up!</p><p>Ghost members sign in using email authentication links, so there are no passwords for people to set or forget. You can turn any list of email subscribers into a database of registered members who can sign in to your site. Like magic.</p><p>Portal makes all of this possible, and it appears by default as a floating button in the bottom-right corner of your site. When people are logged out, clicking it will open a sign-up/sign-in window. When members are logged in, clicking the Portal button will open the account menu where they can edit their name, email, and subscription settings.</p><p>The floating Portal button is completely optional. If you prefer, you can add manual links to your content, navigation, or theme to trigger it instead.</p><p>Like this! <a href=\"#/portal\">Sign up here</a></p><hr><p>As you start to grow your registered audience, you'll be able to get a sense of who you're publishing <em>for</em> and where those people are coming <em>from</em>. Best of all: You'll have a straightforward, reliable way to connect with people who enjoy your work.</p><p>Social networks go in and out of fashion all the time. Email addresses are timeless.</p><p>Growing your audience is valuable no matter what type of site you run, but if your content <em>is</em> your business, then you might also be interested in <a href=\"https://iron.fordeer.agency/sell/\">setting up premium subscriptions</a>.</p>","url":"https://iron.fordeer.agency/portal/","canonical_url":null,"uuid":"ad525305-5cb8-4e52-9358-9fe11ada34ff","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"612df6616c623f9319ddfd28","reading_time":2}},{"node":{"id":"Ghost__Post__612df6616c623f9319ddfd26","title":"Selling premium memberships with recurring revenue","slug":"sell","featured":false,"feature_image":"https://static.ghost.org/v4.0.0/images/organizing-your-content.png","excerpt":"For creators and aspiring entrepreneurs looking to generate a sustainable\nrecurring revenue stream from their creative work, Ghost has built-in payments\nallowing you to create a subscription commerce business.\n\nConnect your Stripe [https://stripe.com] account to Ghost, and you'll be able to\nquickly and easily create monthly and yearly premium plans for members to\nsubscribe to, as well as complimentary plans for friends and family.\n\nGhost takes 0% payment fees, so everything you make is yours to ","custom_excerpt":null,"visibility":"paid","created_at_pretty":"31 August, 2021","published_at_pretty":"31 August, 2021","updated_at_pretty":"31 August, 2021","created_at":"2021-08-31T16:29:05.000+07:00","published_at":"2021-08-31T16:29:06.000+07:00","updated_at":"2021-08-31T16:29:05.000+07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"}],"primary_author":{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"},"primary_tag":{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"For creators and aspiring entrepreneurs looking to generate a sustainable\nrecurring revenue stream from their creative work, Ghost has built-in payments\nallowing you to create a subscription commerce business.\n\nConnect your Stripe [https://stripe.com] account to Ghost, and you'll be able to\nquickly and easily create monthly and yearly premium plans for members to\nsubscribe to, as well as complimentary plans for friends and family.\n\nGhost takes 0% payment fees, so everything you make is yours to keep!\n\nUsing subscriptions, you can build an independent media business like \nStratechery [https://stratechery.com], The Information\n[https://www.theinformation.com], or The Browser [https://thebrowser.com].\n\nThe creator economy is just getting started, and Ghost allows you to build\nsomething based on technology that you own and control.\n\n[https://thebrowser.com]The Browser has over 10,000 paying subscribersMost\nsuccessful subscription businesses publish a mix of free and paid posts to\nattract a new audience, and upsell the most loyal members to a premium offering.\nYou can also mix different access levels within the same post, showing a free\npreview to logged out members and then, right when you're ready for a\ncliffhanger, that's a good time to...","html":"<p>For creators and aspiring entrepreneurs looking to generate a sustainable recurring revenue stream from their creative work, Ghost has built-in payments allowing you to create a subscription commerce business.</p><p>Connect your <a href=\"https://stripe.com\">Stripe</a> account to Ghost, and you'll be able to quickly and easily create monthly and yearly premium plans for members to subscribe to, as well as complimentary plans for friends and family.</p><p>Ghost takes <strong>0% payment fees</strong>, so everything you make is yours to keep!</p><p>Using subscriptions, you can build an independent media business like <a href=\"https://stratechery.com\">Stratechery</a>, <a href=\"https://www.theinformation.com\">The Information</a>, or <a href=\"https://thebrowser.com\">The Browser</a>.</p><p>The creator economy is just getting started, and Ghost allows you to build something based on technology that you own and control.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><a href=\"https://thebrowser.com\"><img src=\"https://static.ghost.org/v4.0.0/images/thebrowser.jpg\" class=\"kg-image\" alt loading=\"lazy\" width=\"1600\" height=\"2000\"></a><figcaption>The Browser has over 10,000 paying subscribers</figcaption></figure><p>Most successful subscription businesses publish a mix of free and paid posts to attract a new audience, and upsell the most loyal members to a premium offering. You can also mix different access levels within the same post, showing a free preview to logged out members and then, right when you're ready for a cliffhanger, that's a good time to...</p>","url":"https://iron.fordeer.agency/sell/","canonical_url":null,"uuid":"db0a1ebb-5854-4403-9802-e2153597464b","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"612df6616c623f9319ddfd26","reading_time":1}},{"node":{"id":"Ghost__Post__612df6616c623f9319ddfd24","title":"How to grow your business around an audience","slug":"grow","featured":false,"feature_image":"https://static.ghost.org/v4.0.0/images/admin-settings.png","excerpt":"A guide to collaborating with other staff users to publish, and some resources to help you with the next steps of growing your business","custom_excerpt":"A guide to collaborating with other staff users to publish, and some resources to help you with the next steps of growing your business","visibility":"public","created_at_pretty":"31 August, 2021","published_at_pretty":"31 August, 2021","updated_at_pretty":"31 August, 2021","created_at":"2021-08-31T16:29:05.000+07:00","published_at":"2021-08-31T16:29:05.000+07:00","updated_at":"2021-08-31T16:29:05.000+07:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"}],"primary_author":{"name":"Ghost","slug":"ghost","bio":"You can delete this user to remove all the welcome posts","profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":"ghost","facebook":"ghost","website":"https://ghost.org"},"primary_tag":{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"},"tags":[{"name":"Getting Started","slug":"getting-started","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"public"}],"plaintext":"As you grow, you'll probably want to start inviting team members and\ncollaborators to your site. Ghost has a number of different user roles for your\nteam:\n\nContributors\nThis is the base user level in Ghost. Contributors can create and edit their own\ndraft posts, but they are unable to edit drafts of others or publish posts.\nContributors are untrusted users with the most basic access to your publication.\n\nAuthors\nAuthors are the 2nd user level in Ghost. Authors can write, edit and publish\ntheir own posts. Authors are trusted users. If you don't trust users to be\nallowed to publish their own posts, they should be set as Contributors.\n\nEditors\nEditors are the 3rd user level in Ghost. Editors can do everything that an\nAuthor can do, but they can also edit and publish the posts of others - as well\nas their own. Editors can also invite new Contributors & Authors to the site.\n\nAdministrators\nThe top user level in Ghost is Administrator. Again, administrators can do\neverything that Authors and Editors can do, but they can also edit all site\nsettings and data, not just content. Additionally, administrators have full\naccess to invite, manage or remove any other user of the site.\n\nThe Owner\nThere is only ever one owner of a Ghost site. The owner is a special user which\nhas all the same permissions as an Administrator, but with two exceptions: The\nOwner can never be deleted. And in some circumstances the owner will have access\nto additional special settings if applicable. For example: billing details, if\nusing Ghost(Pro) [https://ghost.org/pricing/].\n\n> Ask all of your users to fill out their user profiles, including bio and social\nlinks. These will populate rich structured data for posts and generally create\nmore opportunities for themes to fully populate their design.\n\n--------------------------------------------------------------------------------\n\nIf you're looking for insights, tips and reference materials to expand your\ncontent business, here's 5 top resources to get you started:\n\n * How to create a premium newsletter (+ some case studies)\n   [https://ghost.org/blog/how-to-create-a-newsletter/] \n   Learn how others run successful paid email newsletter products\n * The ultimate guide to membership websites for creators\n   [https://ghost.org/blog/membership-sites/]\n   Tips to help you build, launch and grow your new membership business\n * The Newsletter Guide [https://newsletterguide.org/]\n   A 201 guide for taking your newsletters to the next level\n * The proven way to find your niche, explained\n   [https://ghost.org/blog/find-your-niche-creator-economy/]\n   Find the overlap and find a monetizable niche that gets noticed\n * Should you launch a referral program?\n   [https://ghost.org/blog/newsletter-referral-programs/]\n   Strategies for building a sustainable referral growth machine","html":"<p>As you grow, you'll probably want to start inviting team members and collaborators to your site. Ghost has a number of different user roles for your team:</p><p><strong>Contributors</strong><br>This is the base user level in Ghost. Contributors can create and edit their own draft posts, but they are unable to edit drafts of others or publish posts. Contributors are <strong>untrusted</strong> users with the most basic access to your publication.</p><p><strong>Authors</strong><br>Authors are the 2nd user level in Ghost. Authors can write, edit and publish their own posts. Authors are <strong>trusted</strong> users. If you don't trust users to be allowed to publish their own posts, they should be set as Contributors.</p><p><strong>Editors</strong><br>Editors are the 3rd user level in Ghost. Editors can do everything that an Author can do, but they can also edit and publish the posts of others - as well as their own. Editors can also invite new Contributors &amp; Authors to the site.</p><p><strong>Administrators</strong><br>The top user level in Ghost is Administrator. Again, administrators can do everything that Authors and Editors can do, but they can also edit all site settings and data, not just content. Additionally, administrators have full access to invite, manage or remove any other user of the site.<br><br><strong>The Owner</strong><br>There is only ever one owner of a Ghost site. The owner is a special user which has all the same permissions as an Administrator, but with two exceptions: The Owner can never be deleted. And in some circumstances the owner will have access to additional special settings if applicable. For example: billing details, if using <a href=\"https://ghost.org/pricing/\"><strong>Ghost(Pro)</strong></a>.</p><blockquote><em>Ask all of your users to fill out their user profiles, including bio and social links. These will populate rich structured data for posts and generally create more opportunities for themes to fully populate their design.</em></blockquote><hr><p>If you're looking for insights, tips and reference materials to expand your content business, here's 5 top resources to get you started:</p><ul><li><a href=\"https://ghost.org/blog/how-to-create-a-newsletter/\"><strong>How to create a premium newsletter (+ some case studies)</strong></a><strong> </strong> <br>Learn how others run successful paid email newsletter products</li><li><strong><a href=\"https://ghost.org/blog/membership-sites/\">The ultimate guide to membership websites for creators</a></strong><br>Tips to help you build, launch and grow your new membership business</li><li><strong><a href=\"https://newsletterguide.org/\">The Newsletter Guide</a></strong><br>A 201 guide for taking your newsletters to the next level</li><li><a href=\"https://ghost.org/blog/find-your-niche-creator-economy/\"><strong>The proven way to find your niche, explained</strong></a><br>Find the overlap and find a monetizable niche that gets noticed</li><li><strong><a href=\"https://ghost.org/blog/newsletter-referral-programs/\">Should you launch a referral program? </a></strong><br>Strategies for building a sustainable referral growth machine</li></ul>","url":"https://iron.fordeer.agency/grow/","canonical_url":null,"uuid":"a974eb9d-f201-4f24-abb8-3515e4f90cce","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"612df6616c623f9319ddfd24","reading_time":2}}]}},"pageContext":{"pageNumber":0,"humanPageNumber":1,"skip":0,"limit":12,"numberOfPages":1,"previousPagePath":"","nextPagePath":""}},"staticQueryHashes":["176528973","2358152166","2561578252","2731221146","4145280475"]}