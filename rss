<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[IRON]]></title><description><![CDATA[Thoughts, stories and ideas.]]></description><link>http://localhost:8000/</link><image><url>http://localhost:8000/favicon.png</url><title>IRON</title><link>http://localhost:8000/</link></image><generator>Ghost 2.9</generator><lastBuildDate>Tue, 31 Aug 2021 14:57:35 GMT</lastBuildDate><atom:link href="http://localhost:8000/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[GraphQL on Rails:
From zero to the first query]]></title><description><![CDATA[A hitchhiker‚Äôs guide to developing GraphQL applications with Rails on the
backend side and React/Apollo on the frontend side. Follow this multi-part
tutorial to learn both the basics and the advanced topics by example and feel
the power of this modern technology.

GraphQL [https://graphql.org/] is one of those new shiny things we‚Äôve been
seeing here, there and everywhere: blog posts
[https://dev.to/evilmartians/exposing-permissions-in-graphql-apis-with-action-policy-536a-temp-slug-455298?preview]]></description><link>http://localhost:8000/graphql-on-rails-from-zero-to-the-first-query/</link><guid isPermaLink="false">Ghost__Post__612e07af894d3804d9ca6d95</guid><dc:creator><![CDATA[IRON]]></dc:creator><pubDate>Tue, 31 Aug 2021 10:45:05 GMT</pubDate><media:content url="https://iron.fordeer.agency/content/images/2021/08/cover-41f83d0.png" medium="image"/><content:encoded><![CDATA[<img src="https://iron.fordeer.agency/content/images/2021/08/cover-41f83d0.png" alt="GraphQL on Rails:
From zero to the first query"/><p>A hitchhiker‚Äôs guide to developing GraphQL applications with Rails on the backend side and React/Apollo on the frontend side. Follow this multi-part tutorial to learn both the basics and the advanced topics by example and feel the power of this modern technology.</p><p><a href="https://graphql.org/">GraphQL</a> is one of those new shiny things we‚Äôve been seeing here, there and everywhere: <a href="https://dev.to/evilmartians/exposing-permissions-in-graphql-apis-with-action-policy-536a-temp-slug-455298?preview=5921586e85991fd5515f56b0ab8401d5fa1acb757e53ffc9c32c06243664d434f816c731482815c58f8a058def1cc2ae05638aacfce6c09d473010dc">blog posts</a>, <a href="https://www.graphqlconf.org/">conferences</a>, <a href="https://graphqlradio.com/">podcasts</a>, maybe, even newspapers. It sounds like you should hurry up and start rewriting your application in GraphQL instead of REST as soon as possible, right? Not exactly. Remember: there is no silver bullet. It‚Äôs essential to understand the pros and cons of the technology before making a paradigm-shift decision.</p><p>Check out <a href="https://evilmartians.com/chronicles/graphql-on-rails-2-updating-the-data">Part 2</a> and <a href="https://evilmartians.com/chronicles/graphql-on-rails-3-on-the-way-to-perfection">Part 3</a></p><p>In this series, we‚Äôre going to walk you through a no-frills guide to the development of GraphQL applications, talking about not only its advantages but also its caveats and pitfalls (and, of course, the ways to deal with them).</p><h2 id="graphql-in-a-nutshell">GraphQL in a nutshell</h2><p>There are a lot of other query languages, for instance, SQL and XPath.</p><p>According to the <a href="https://graphql.github.io/graphql-spec/">specification</a>, GraphQL is a <em>query language</em> and <em>runtime</em> (or <em>execution engine</em>). Query language, <a href="https://en.wikipedia.org/wiki/Query_language">by definition</a>, describes how to communicate with an information system. Runtime is responsible for fulfilling queries with data.</p><p>At the core of every GraphQL application lies a <a href="https://graphql.org/learn/schema/"><em>schema</em></a>: it describes the underlying data in the form of a directed graph. The runtime must execute queries according to the schema (and some general rules from the specification). That means, every valid GraphQL server runs queries in the same manner and returns data in the same format for the same schema. In other words, the schema is everything clients should know about the API.</p><p>Here is an example of a simple GraphQL query:</p><pre><code>query getProduct($id: Int!) {
  product(id: $id) {
    id
    title
    manufacturer {
      name
    }
  }
}
</code></pre><p>Let‚Äôs dissect it line by line:</p><ul><li>We define a named query (<code>getProduct</code> is the operation name) accepting a single argument (<code>$id</code>). The operation name is optional, but it helps readability and could be used by frontend for caching.</li><li>We ‚Äúselect‚Äù the <code>product</code> field from the ‚Äúroot‚Äù of the schema and pass the <code>$id</code> value as an argument.</li><li>We describe the fields we want to fetch: in this case, we want to get the <code>id</code> and <code>title</code> of the product as well as the <code>name</code> of the manufacturer.</li></ul><blockquote>Essentially, a query represents a sub-graph of the schema, which brings the first benefit of GraphQL‚Äîwe can fetch only this data we need and all we need at once, in a single query.</blockquote><p>Check out <a href="https://stackoverflow.com/questions/44564905/what-is-over-fetching-or-under-fetching">this Stack Overflow post</a> to learn more about both overfetching and underfetching.</p><p>This way, we solve one of the common problems of the traditional REST APIs‚Äî<em>overfetching</em>.</p><p>Another noticeable feature of GraphQL schemas is they are <em>strongly</em> <em>typed</em>: both client and runtime ensure that the data passed is valid from the perspective of the application‚Äôs type system. For example, if someone mistakenly passes a string value as the <code>$id</code> to the query above, the client fails with the exception without even trying to perform a request.</p><p>There are plenty of tools to convert a schema into an interactive documentation website, standalone (e.g., <a href="https://github.com/graphql/graphiql">GraphiQL</a> or <a href="https://2fd.github.io/graphdoc">graphdoc</a>) and framework-specific (e.g., <a href="https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm">Apollo DevTools</a>).</p><p>And the last but not least bonus is a <em>schema</em> <em>introspection</em>: clients can learn the API from the schema itself, without any additional documentation sources.</p><p>We‚Äôve just learned a bunch of theoretical aspects of GraphQL. Now it‚Äôs time to do some coding exercises to make sure you won‚Äôt forget everything tomorrow‚Äôs morning.</p><h2 id="what-are-we-going-to-build">What are we going to build?</h2><p>During this series, we will be building an application representing a ‚ÄúMartian Library‚Äù‚Äîa personal online collection of movies, books, and other art objects related to the Red Planet.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://iron.fordeer.agency/content/images/2021/08/application-32576ed.png" class="kg-image" alt="GraphQL on Rails:
From zero to the first query" loading="lazy" width="1600" height="713" srcset="https://iron.fordeer.agency/content/images/size/w600/2021/08/application-32576ed.png 600w, https://iron.fordeer.agency/content/images/size/w1000/2021/08/application-32576ed.png 1000w, https://iron.fordeer.agency/content/images/2021/08/application-32576ed.png 1600w" sizes="(min-width: 720px) 720px"><figcaption><p style="margin: 0px;">The application we are going to&nbsp;build</p></figcaption></img></figure><p>For this tutorial, we‚Äôre going to use:</p><ul><li>Ruby 2.6 and Rails 6 (<a href="https://evilmartians.com/chronicles/rails-6-b-sides-and-rarities">release candidate is already here</a>) for backend.</li><li>Node.js 9+, React 16.3+, and Apollo (client version 2+) for frontend (and make sure you have yarn installed according to the <a href="https://yarnpkg.com/en/docs/install#mac-stable">instruction</a>).</li></ul><p>You can find the source code <a href="https://github.com/evilmartians/chronicles-gql-martian-library/tree/part-1">here</a>‚Äîdon‚Äôt forget to run <code>bundle install &amp;&amp; yarn install</code> before the first run. <a href="https://github.com/evilmartians/chronicles-gql-martian-library">Master</a> represents a current state of the project.</p><h2 id="setting-up-a-new-rails-project">Setting up a new Rails project</h2><p>If at the time of reading this article Rails 6.0 hasn‚Äôt been released yet, you might need to install the release candidate first:</p><pre><code>$ gem install rails --pre
$ rails -v
=&gt; Rails 6.0.0.rc1
</code></pre><p>Now we‚Äôre ready to run this unexpectedly long <code>rails new</code> command:</p><pre><code>$ rails new martian-library -d postgresql --skip-action-mailbox --skip-action-text --skip-spring --webpack=react -T --skip-turbolinks
</code></pre><p>We prefer <em>okonomi</em> to <a href="https://dhh.dk/2012/rails-is-omakase.html"><em>omakase</em></a>: skip frameworks and libraries we don‚Äôt need, choose PostgreSQL as our database, preconfigure Webpacker to use React, and skip tests (don‚Äôt worry‚Äìwe‚Äôll add RSpec soon).</p><p>Before you start, it‚Äôs strongly recommended that you disable all the unnecessary generators in the ¬†<code>config/application.rb</code>:</p><pre><code>config.generators do |g|
  g.test_framework  false
  g.stylesheets     false
  g.javascripts     false
  g.helper          false
  g.channel         assets: false
end
</code></pre><h2 id="preparing-the-data-model">Preparing the data model</h2><p>We need at least two models to start:</p><ul><li><code>Item</code> to describe any entity (book, movie, etc.) that we want to store in the library</li><li><code>User</code> to represent the application user who can manage items in the collection.</li></ul><p>Let‚Äôs generate them:</p><pre><code>$ rails g model User first_name last_name email
$ rails g model Item title description:text image_url user:references
</code></pre><p>Don‚Äôt forget to add the <code>has_many :items</code> association to <code>app/models/user.rb</code>:</p><pre><code># app/models/user.rb
class User &lt; ApplicationRecord
  has_many :items, dependent: :destroy
end
</code></pre><p>Let‚Äôs add some pre-generated data to <code>db/seeds.rb</code>:</p><pre><code># db/seeds.rb
john = User.create!(
  email: "john.doe@example.com",
  first_name: "John",
  last_name: "Doe"
)

jane = User.create!(
  email: "jane.doe@example.com",
  first_name: "Jane",
  last_name: "Doe"
)

Item.create!(
  [
    {
      title: "Martian Chronicles",
      description: "Cult book by Ray Bradbury",
      user: john,
      image_url: "https://upload.wikimedia.org/wikipedia/en/4/45/The-Martian-Chronicles.jpg"
    },
    {
      title: "The Martian",
      description: "Novel by Andy Weir about an astronaut stranded on Mars trying to survive",
      user: john,
      image_url: "https://upload.wikimedia.org/wikipedia/en/c/c3/The_Martian_2014.jpg"
    },
    {
      title: "Doom",
      description: "A group of Marines is sent to the red planet via an ancient " \
                   "Martian portal called the Ark to deal with an outbreak of a mutagenic virus",
      user: jane,
      image_url: "https://upload.wikimedia.org/wikipedia/en/5/57/Doom_cover_art.jpg"
    },
    {
      title: "Mars Attacks!",
      description: "Earth is invaded by Martians with unbeatable weapons and a cruel sense of humor",
      user: jane,
      image_url: "https://upload.wikimedia.org/wikipedia/en/b/bd/Mars_attacks_ver1.jpg"
    }
  ]
)
</code></pre><p>Finally, we‚Äôre ready to initialize our database:</p><pre><code>$ rails db:create db:migrate db:seed
</code></pre><p>Now that we‚Äôve put some information into our system, let‚Äôs add a way to access it!</p><h2 id="adding-a-graphql-endpoint">Adding a GraphQL endpoint</h2><p>For crafting our GraphQL API, we will use the <a href="https://github.com/rmosolgo/graphql-ruby">graphql-ruby</a> gem:</p><pre><code># First, add it to the Gemfile
$ bundle add graphql --version="~&gt; 1.9"
# Then, run the generator
$ rails generate graphql:install
</code></pre><p>You might be surprised by the number of files a minimal <code>graphql-ruby</code> application requires: this boilerplate is the price we pay for all the goodies we described above.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/generator-d6a5280.png" class="kg-image" alt="GraphQL on Rails:
From zero to the first query" loading="lazy"><figcaption><p style="margin: 0px;">The result of&nbsp;executing <code style="font-family: &quot;Fira Code&quot;, &quot;Lucida Console&quot;, Monaco, monospace; font-size: 1em; color: rgb(191, 108, 53); font-feature-settings: &quot;calt&quot;; text-rendering: optimizelegibility; white-space: pre-wrap;">graphql:install</code> generator</p></figcaption></img></figure><p>First of all, let‚Äôs take a look at the schema, <code>martian_library_schema.rb</code>:</p><pre><code># app/graphql/martian_library_schema.rb
class MartianLibrarySchema &lt; GraphQL::Schema
  query(Types::QueryType)
  mutation(Types::MutationType)
end
</code></pre><p>The schema declares that all the queries should go to <code>Types::QueryType</code> while mutations should go to <code>Types::MutationType</code>. We‚Äôre going to dig deeper into mutations in the second part of the series; the goal of this article is to learn how to write and execute queries. Thus, let‚Äôs open the <code>types/query_type.rb</code> class‚Äîit is an entry point for all the queries. What‚Äôs inside?</p><pre><code># app/graphql/types/query_type.rb
module Types
  class QueryType &lt; Types::BaseObject
    # Add root-level fields here.
    # They will be entry points for queries on your schema.

    # TODO: remove me
    field :test_field, String, null: false,
      description: "An example field added by the generator"
    def test_field
      "Hello World!"
    end
  end
end
</code></pre><p>It turns out that <code>QueryType</code> is just a regular type: it inherits from the <code>Types::BaseObject</code> (which we will use as a base class for all types), and it has <em>field</em> definitions‚Äìthe nodes of our data graph. The only thing that makes <code>QueryType</code> different is that GraphQL requires this type to exist (while <em>mutation</em> and <em>subscription</em> types are optional).</p><p>Have noticed that the code above is actually a ‚Äúhello world‚Äù app? Before going further (and boring you with by the amount of code), we‚Äôd like to show you how to get this ‚Äúhello world‚Äù in your browser.</p><p>Let‚Äôs see what has been added to the <code>config/routes.rb</code> file by the generator:</p><pre><code># config/routes.rb
Rails.application.routes.draw do
  mount GraphiQL::Rails::Engine, at: "/graphiql", graphql_path: "/graphql" if Rails.env.development?
  post "/graphql", to: "graphql#execute"
end
</code></pre><p>Mounting <code>GraphiQL::Rails::Engine</code> allows us to test our queries and mutations using a web interface called <a href="https://github.com/graphql/graphiql">GraphiQL</a>. As we discussed in the introduction, the schema can be inspected, and GraphiQL uses this feature to build interactive documentation for us. It‚Äôs time to give it a shot!</p><pre><code># Let's run a Rails web server
$ rails s
</code></pre><p>Open up <a href="http://localhost:3000/graphiql">http://localhost:3000/graphiql</a> in the browser:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/graphiql-4633e9d.png" class="kg-image" alt="GraphQL on Rails:
From zero to the first query" loading="lazy"><figcaption><p style="margin: 0px;">GraphiQL UI</p></figcaption></img></figure><p>In the left pane, you can type a query to execute, then click the ‚Äúplay‚Äù button (or hit <em>Ctrl/Cmd+Enter</em>) and get the response in the right pane. By clicking the ‚ÄúDocs‚Äù link at the right top corner, you can explore your schema.</p><p>Let‚Äôs take a look at our logs‚Äîwe want to know what happens when we click the execute button.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/execute_log-e654371.png" class="kg-image" alt="GraphQL on Rails:
From zero to the first query" loading="lazy"><figcaption><p style="margin: 0px;">Execution logs</p></figcaption></img></figure><p>GraphQL is transport-agnostic, but most implementations, including <code>ruby-graphql</code>, use HTTP POST requests.</p><p>Requests are sent to <code>GraphqlController</code>, which has also been added to the application by the <code>graphql</code> gem generator.</p><p>Take a look at the <code>GraphqlController#execute</code> action:</p><pre><code># app/controllers/graphql_controller.rb
def execute
  variables = ensure_hash(params[:variables])
  query = params[:query]
  operation_name = params[:operationName]
  context = {
    # Query context goes here, for example:
    # current_user: current_user,
  }
  result = GraphqlSchema.execute(
    query,
    variables: variables,
    context: context,
    operation_name: operation_name
  )
  render json: result
rescue StandardError =&gt; e
  raise e unless Rails.env.development?

  handle_error_in_development e
end
</code></pre><p>This action calls the <code>GraphqlSchema#execute</code> method with the following parameters:</p><ul><li><code>query</code> and <code>variables</code> represent a query string and arguments sent by a client respectively;</li><li><code>context</code> is an arbitrary hash, which will be available during the query execution everywhere;</li><li><code>operation_name</code> picks a named operation from the incoming request to execute (could be empty).</li></ul><p>All the magic happens inside this method: it parses the query, detects all the types that should be used for building the response, and resolves all the requested fields. The only thing we need to do is to define the types and declare how fields should be resolved.</p><h2 id="what%E2%80%99s-in-the-martian-library">What‚Äôs in the Martian Library?</h2><p>Let‚Äôs move from ‚Äúhello world‚Äù to something real: remove the example contents from <code>Types::QueryType</code> and register a field called <code>:items</code> which will return all the items from the library. We also need to add a resolver method for this field (the resolver method name must match the field name):</p><pre><code># app/graphql/types/query_type.rb
module Types
  class QueryType &lt; Types::BaseObject
    field :items,
          [Types::ItemType],
          null: false,
          description: "Returns a list of items in the martian library"

    def items
      Item.all
    end
  end
end
</code></pre><p>Each field definition contains a name, a result type, and options; <code>:null</code> is required and must be set to either <code>true</code> or <code>false</code>. We also define optional <code>:description</code>‚Äîit‚Äôs a good practice to add a human-readable message to a field: it will be automatically added to documentation providing more context to developers. The array notation for the result type, <code>[Types::ItemType]</code>, means that the field value must be an array and each element of this array must be represented using the <code>Types::ItemType</code> type.</p><p>But we haven‚Äôt defined <code>ItemType</code> yet, right? Hopefully, the <code>graphql</code> gem will give us a handy generator:</p><pre><code>$ rails g graphql:object item
</code></pre><p>Now we can modify the newly created <code>app/graphql/types/item_type.rb</code> to our liking.</p><pre><code># app/graphql/types/item_type.rb
module Types
  class ItemType &lt; Types::BaseObject
    field :id, ID, null: false
    field :title, String, null: false
    field :description, String, null: true
    field :image_url, String, null: true
  end
end
</code></pre><p>You may use UUID as a primary key in your table if you are worried about exposing sequential IDs, but let‚Äôs go with the easy way now.</p><p>As you can see, we‚Äôre exposing three fields in <code>ItemType</code>:</p><ul><li>non-nullable fields <code>id</code> and <code>title</code></li><li>a nullable field <code>description</code></li></ul><p>Our execution engine resolves fields using the following algorithm (slightly simplified):</p><ul><li>First, it looks for the method with the same name defined in the type class itself (like we did earlier in the <code>QueryType</code> for <code>items</code>); we can access the object being resolved using the <code>object</code> method.</li><li>If no such method defined, it tries to call the method with the same name on the <code>object</code> itself.</li></ul><p>We do not define any methods in our type class; thus, we assume that the underlying implements all the fields‚Äô methods.</p><p>Go back to <a href="http://localhost:3000/graphiql">http://localhost:3000/graphiql</a>, execute the following query, and make sure that you get the list of all items in response:</p><pre><code>{
  items {
    id
    title
    description
  }
}
</code></pre><p>So far, we haven‚Äôt added any functionality that leverages the power of graphs‚Äîour current graph‚Äôs depth is one. Let‚Äôs grow the graph by adding a non-primitive node to <code>ItemType</code>, for example, a <code>user</code> field to represent the user who created the item:</p><pre><code># app/graphql/types/item_type.rb
module Types
  class ItemType &lt; Types::BaseObject
    # ...
    field :user, Types::UserType, null: false
  end
end
</code></pre><p>Let‚Äôs repeat the same generator spell to create a new type class:</p><pre><code>$ rails g graphql:object user
</code></pre><p>This time we also want to add a computed field‚Äî<code>full_name</code>:</p><pre><code># app/graphql/types/user_type.rb
module Types
  class UserType &lt; Types::BaseObject
    field :id, ID, null: false
    field :email, String, null: false
    field :full_name, String, null: false

    def full_name
      # `object` references the user instance
      [object.first_name, object.last_name].compact.join(" ")
    end
  end
end
</code></pre><p>Let‚Äôs transform our query to fetch users along with items:</p><pre><code>{
  items {
    id
    title
    user {
      id
      email
    }
  }
}
</code></pre><p>At this point, we‚Äôre ready to move our attention from the backend side to the frontend side. Let‚Äôs build a client for this API!</p><h2 id="configuring-the-frontend-application">Configuring the frontend application</h2><p>If you‚Äôre using Google Chrome, mind installing the Apollo <a href="https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm">extension</a>.</p><p>As we already mentioned, we recommend you install the <a href="https://www.apollographql.com/docs/react/">Apollo</a> framework for dealing with GraphQL client-side.</p><p>To get the ball rolling, we need to install all the required dependencies:</p><pre><code>$ yarn add apollo-client apollo-cache-inmemory apollo-link-http apollo-link-error apollo-link graphql graphql-tag react-apollo
</code></pre><p>We didn‚Äôt include any package-adding types to JS (<a href="http://www.typescriptlang.org/">TypeScript</a> or <a href="https://flow.org/">Flow</a>) so as not to make this tutorial too complicated. In practice, using typed JS with GraphQL makes a lot of sense since we already have a types system. For instance, <a href="https://github.com/apollographql/apollo-tooling">apollo-codegen</a> can generate type signatures automatically.</p><p>Let‚Äôs take a look at some of the installed packages:</p><ul><li>We use <code>graphql-tag</code> to build our first queries.</li><li><code>apollo-client</code> is a generic framework-agnostic package for performing and caching GraphQL requests.</li><li><code>apollo-cache-inmemory</code> is a storage implementation for Apollo cache.</li><li><code>react-apollo</code> contains a set of React components for displaying data.</li><li><code>apollo-link</code> and other <em>links</em> implement a middleware pattern for <code>apollo-client</code> operations (you can find further details <a href="https://www.apollographql.com/docs/link/overview.html">here</a>).</li></ul><p>Now we need to create an entry point for our frontend application. Remove <code>hello_react.jsx</code> from the <code>packs</code> folder and add <code>index.js</code>:</p><pre><code>$ rm app/javascript/packs/hello_react.jsx &amp;&amp; touch app/javascript/packs/index.js
</code></pre><p>For the sake of debugging, it‚Äôs good enough to stay with the following content:</p><pre><code>// app/javascript/packs/index.js
console.log('üëª');
</code></pre><p>Let‚Äôs generate a controller to serve our frontend application:</p><pre><code>$ rails g controller Library index --skip-routes
</code></pre><p>Update <code>app/views/library/index.html.erb</code> to contain the React root element and a link to our <em>pack</em>:</p><pre><code>&lt;!-- app/views/library/index.html.erb --&gt;
&lt;div id="root" /&gt;
&lt;%= javascript_pack_tag 'index' %&gt;
</code></pre><p>Finally, let‚Äôs register a new route in the <code>config/routes.rb</code>:</p><pre><code># config/routes.rb
root 'library#index'
</code></pre><p>Restart your Rails server and make sure you see the ghost in the browser console. Don‚Äôt be scared.</p><h2 id="configuring-apollo">Configuring Apollo</h2><p>Create a file for storing our application‚Äôs Apollo config:</p><pre><code>$ mkdir -p app/javascript/utils &amp;&amp; touch app/javascript/utils/apollo.js
</code></pre><p>In this file we want to configure the two core entities of the Apollo application, the client and the cache (or more precisely, the functions to create both):</p><pre><code>// app/javascript/utils/apollo.js

// client
import { ApolloClient } from 'apollo-client';
// cache
import { InMemoryCache } from 'apollo-cache-inmemory';
// links
import { HttpLink } from 'apollo-link-http';
import { onError } from 'apollo-link-error';
import { ApolloLink, Observable } from 'apollo-link';
export const createCache = () =&gt; {
  const cache = new InMemoryCache();
  if (process.env.NODE_ENV === 'development') {
    window.secretVariableToStoreCache = cache;
  }
  return cache;
};
</code></pre><p>Caching is one of the most powerful features of Apollo. Sometimes it becomes overpowering, and you might prefer a more straightforward solution. In any case, it‚Äôs worth learning how it works. Find more details about how Apollo caching works <a href="https://www.apollographql.com/docs/react/advanced/caching.html">here</a>.</p><p>Let‚Äôs take a second and look at how cache works.</p><p>Each query response is put into the cache (the corresponding request is used to generate the cache key). Before making a request, <code>apollo-client</code> ensures that the response hasn‚Äôt been cached yet, and if it has been‚Äìthe request is not performed. This behavior is configurable: for instance, we can turn off caching for a particular request or ask the client to look for a cache entry of a different query.</p><p>One important thing we need to know about the cache mechanism for this tutorial is that, by default, a cache key is a concatenation of the object <code>id</code> and <code>__typename</code>. Thus, fetching the same object twice would result only in one request.</p><p>Back to coding. Since we use HTTP POST as a transport, we need to attach a proper CSRF token to every request to pass the <a href="https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf">forgery protection check</a> in the Rails app. We can grab it from <code>meta[name="csrf-token"]</code> (which is generated by <code>&lt;%= csrf_meta_tags %&gt;</code>):</p><pre><code>// app/javascript/utils/apollo.js
// ...
// getToken from meta tags
const getToken = () =&gt;
  document.querySelector('meta[name="csrf-token"]').getAttribute('content');
const token = getToken();
const setTokenForOperation = async operation =&gt;
  operation.setContext({
    headers: {
      'X-CSRF-Token': token,
    },
  });
// link with token
const createLinkWithToken = () =&gt;
  new ApolloLink(
    (operation, forward) =&gt;
      new Observable(observer =&gt; {
        let handle;
        Promise.resolve(operation)
          .then(setTokenForOperation)
          .then(() =&gt; {
            handle = forward(operation).subscribe({
              next: observer.next.bind(observer),
              error: observer.error.bind(observer),
              complete: observer.complete.bind(observer),
            });
          })
          .catch(observer.error.bind(observer));
        return () =&gt; {
          if (handle) handle.unsubscribe();
        };
      })
  );
</code></pre><p>Let‚Äôs look at how we can log errors:</p><pre><code>// app/javascript/utils/apollo.js
//...
// log erors
const logError = (error) =&gt; console.error(error);
// create error link
const createErrorLink = () =&gt; onError(({ graphQLErrors, networkError, operation }) =&gt; {
  if (graphQLErrors) {
    logError('GraphQL - Error', {
      errors: graphQLErrors,
      operationName: operation.operationName,
      variables: operation.variables,
    });
  }
  if (networkError) {
    logError('GraphQL - NetworkError', networkError);
  }
})
</code></pre><p>In production, it makes more sense to use an exception tracking service (e.g., Sentry or Honeybadger): just override the <code>logError</code> function to send errors to the external system.</p><p>We‚Äôre almost there‚Äîlet‚Äôs tell the client about the endpoint for making queries:</p><pre><code>// app/javascript/utils/apollo.js
//...
// http link
const createHttpLink = () =&gt; new HttpLink({
  uri: '/graphql',
  credentials: 'include',
})
</code></pre><p>Finally, we‚Äôre ready to create an Apollo client instance:</p><pre><code>// app/javascript/utils/apollo.js
//...
export const createClient = (cache, requestLink) =&gt; {
  return new ApolloClient({
    link: ApolloLink.from([
      createErrorLink(),
      createLinkWithToken(),
      createHttpLink(),
    ]),
    cache,
  });
};
</code></pre><h2 id="the-very-first-query">The very first query</h2><p>We‚Äôre going to use a <a href="https://reactjs.org/docs/context.html#contextprovider">provider pattern</a> to pass the client instances to React components:</p><pre><code>$ mkdir -p app/javascript/components/Provider &amp;&amp; touch app/javascript/components/Provider/index.js
</code></pre><p>It‚Äôs the first time we are using an <code>ApolloProvider</code> component from the <code>react-apollo</code> library:</p><pre><code>// app/javascript/components/Provider/index.js
import React from 'react';
import { ApolloProvider } from 'react-apollo';
import { createCache, createClient } from '../../utils/apollo';

export default ({ children }) =&gt; (
  &lt;ApolloProvider client={createClient(createCache())}&gt;
    {children}
  &lt;/ApolloProvider&gt;
);
</code></pre><p>Let‚Äôs change our <code>index.js</code> to use the newly created provider:</p><pre><code>// app/javascript/packs/index.js
import React from 'react';
import { render } from 'react-dom';
import Provider from '../components/Provider';

render(&lt;Provider&gt;üëª&lt;/Provider&gt;, document.querySelector('#root'));
</code></pre><p>If you use <code>Webpacker v3</code> you may need to import <code>babel-polyfill</code> to use all the cool JavaScript tricks like async/await. Don‚Äôt worry about the polyfill‚Äôs size; <code>babel-preset-env</code> will remove everything you don‚Äôt need.</p><p>Let‚Äôs create a <code>Library</code> component to display the list of items on the page:</p><pre><code>$ mkdir -p app/javascript/components/Library &amp;&amp; touch app/javascript/components/Library/index.js
</code></pre><p>We‚Äôre going to use the <code>Query</code> component from <code>react-apollo</code>, which accepts the <code>query</code> string as a property to fetch the data on mount:</p><pre><code>// app/javascript/components/Library/index.js
import React from 'react';
import { Query } from 'react-apollo';
import gql from 'graphql-tag';

const LibraryQuery = gql`
  {
    items {
      id
      title
      user {
        email
      }
    }
  }
`;

export default () =&gt; (
  &lt;Query query={LibraryQuery}&gt;
    {({ data, loading }) =&gt; (
      &lt;div&gt;
        {loading
          ? 'loading...'
          : data.items.map(({ title, id, user }) =&gt; (
              &lt;div key={id}&gt;
                &lt;b&gt;{title}&lt;/b&gt; {user ? `added by ${user.email}` : null}
              &lt;/div&gt;
            ))}
      &lt;/div&gt;
    )}
  &lt;/Query&gt;
);
</code></pre><p>We can access the loading state and loaded data through the corresponding <code>loading</code> and <code>data</code> properties (passed using a so-called <a href="https://reactjs.org/docs/render-props.html">render-props pattern</a>).</p><p>Don‚Äôt forget to add the component to the main page:</p><pre><code>// app/javascript/packs/index.js
import React from 'react';
import { render } from 'react-dom';
import Provider from '../components/Provider';
import Library from '../components/Library';

render(
  &lt;Provider&gt;
    &lt;Library /&gt;
  &lt;/Provider&gt;,
  document.querySelector('#root')
);
</code></pre><p>If you reload the page you should see the list of items with emails of users who added them:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/items-b791b9f.png" class="kg-image" alt="GraphQL on Rails:
From zero to the first query" loading="lazy"><figcaption><p style="margin: 0px;">List of&nbsp;items with emails of&nbsp;users</p></figcaption></img></figure><p>Congratulations! You‚Äôve just made the very first step towards GraphQL happiness!</p><h2 id="%E2%80%A6and-the-very-first-problem">‚Ä¶And the very first problem</h2><p>Everything seems to work fine, but let‚Äôs take a look at our server logs:</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn.evilmartians.com/front/posts/graphql-on-rails-1-from-zero-to-the-first-query/n_plus_one-77d1121.png" class="kg-image" alt="GraphQL on Rails:
From zero to the first query" loading="lazy"><figcaption><p style="margin: 0px;">N + 1</p></figcaption></img></figure><p>The SQL query <code>SELECT * FROM users WHERE id = ?</code> is executed <strong>four times</strong>, which means that we hit the famous <em>N+1 problem</em>‚Äìserver makes a query for each item in the collection to get the corresponding user info.</p><p>Before fixing the problem, we need to make sure that it‚Äôs safe to make code modifications without breaking anything‚Äîlet‚Äôs write some tests!</p><h2 id="writing-some-specs">Writing some specs</h2><p>Since we‚Äôre running on the edge, we need the upcoming version of the gem.</p><p>Now it‚Äôs time to install and configure RSpec, or more precisely, the <code>rspec-rails</code> gem:</p><pre><code># Add gem to the Gemfile
$ bundle add rspec-rails --version="4.0.0.beta2" --group="development,test"
# Generate the initial configuration
$ rails generate rspec:install
</code></pre><p>To make it easier to generate data for tests let‚Äôs install <a href="https://github.com/thoughtbot/factory_bot">factory_bot</a>:</p><pre><code>$ bundle add factory_bot_rails --version="~&gt; 5.0" --group="development,test"
</code></pre><p>Make factory methods (<code>create</code>, <code>build</code>, etc.) globally visible in tests by adding <code>config.include FactoryBot::Syntax::Methods</code> to the <code>rails_helper.rb</code>.</p><p>Since we created our models before adding Factory Bot, we should generate our factories manually. Let‚Äôs create a single file, <code>spec/factories.rb</code>, for that:</p><pre><code># spec/factories.rb
FactoryBot.define do
  factory :user do
    # Use sequence to make sure that the value is unique
    sequence(:email) { |n| "user-#{n}@example.com" }
  end

  factory :item do
    sequence(:title) { |n| "item-#{n}" }
    user
  end
end
</code></pre><p>Now we are ready to write our first test. Let‚Äôs create a spec file for <code>QueryType</code>:</p><pre><code>$ mkdir -p spec/graphql/types
$ touch spec/graphql/types/query_type_spec.rb
</code></pre><p>The simplest query test looks like this:</p><pre><code># spec/graphql/types/query_type_spec.rb
require "rails_helper"

RSpec.describe Types::QueryType do
  describe "items" do
    let!(:items) { create_pair(:item) }

    let(:query) do
      %(query {
        items {
          title
        }
      })
    end

    subject(:result) do
      MartianLibrarySchema.execute(query).as_json
    end

    it "returns all items" do
      expect(result.dig("data", "items")).to match_array(
        items.map { |item| { "title" =&gt; item.title } }
      )
    end
  end
end
</code></pre><p>Testing GraphQL might feel repetitive. Should it happen to you‚Äîconsider using fixtures and the <a href="https://github.com/nepalez/fixturama">fixturama</a> gem.</p><p>First, we create a pair of items in our database. Then, we define the query under test and the subject (<code>result</code>) by calling the <code>GraphqlSchema.execute</code> method. Remember, we had a similar line in the <code>GraphqlController#execute</code>?</p><p>This example is very straightforward: we‚Äôre not passing either <code>variables</code> or <code>context</code> to the <code>execute</code> call, though we definitely can do that if needed.</p><p>Now we‚Äôre confident enough to fix ‚Äúthe bug‚Äù‚Äîthe N+1 problem!</p><h2 id="graphql-vs-n1-problem">GraphQL vs. N+1 problem</h2><p>The easiest way to avoid N+1 queries is to use <a href="https://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations">eager loading</a>. In our case, we need to preload users when making a query to fetch items in <code>QueryType</code>:</p><pre><code># /app/graphql/types/query_type.rb
module Types
  class QueryType &lt; Types::BaseObject
    # ...

    def items
      Item.preload(:user)
    end
  end
end
</code></pre><p>This solution can help in simple situations, but it‚Äôs not very efficient: the following code preloads users even if the client does not need them, e.g.:</p><pre><code>items {
  title
}
</code></pre><p>Learn how to solve the N+1 problem using batch loading by example from the <a href="https://dev.to/evilmartians/active-storage-meets-graphql-pt-2-exposing-attachment-urls-2mdn">‚ÄúActive Storage meets GraphQL‚Äù</a> post in our dev.to blog.</p><p>Discussing other ways to solve the N+1 problem is worthy of a dedicated post and out of this tutorial‚Äôs scope.<br>Most of the solutions fit the following two groups:</br></p><ul><li>lazy eager loading (e.g., using the <a href="https://github.com/DmitryTsepelev/ar_lazy_preload">ar_lazy_preload</a> gem)</li><li>batch loading (e.g., using the <a href="https://github.com/Shopify/graphql-batch">graphql-batch</a> gem)</li></ul><hr><p>That‚Äôs all for today! We learned a lot about GraphQL, completed all the routine work of configuring the backend and frontend applications, made the first query, and even found and fixed the first bug. And that‚Äôs just a tiny step (despite the size of the article) in our journey. We‚Äôll come back shortly and unveil how to manipulate data using GraphQL mutations and keep it up-to-date with subscriptions. Stay tuned!</p></hr>]]></content:encoded></item><item><title><![CDATA[Building your audience with subscriber signups]]></title><description><![CDATA[How Ghost allows you to turn anonymous readers into an audience of active subscribers, so you know what's working and what isn't.]]></description><link>http://localhost:8000/portal/</link><guid isPermaLink="false">Ghost__Post__612df6616c623f9319ddfd28</guid><category><![CDATA[Getting Started]]></category><dc:creator><![CDATA[Ghost]]></dc:creator><pubDate>Tue, 31 Aug 2021 09:29:07 GMT</pubDate><media:content url="https://static.ghost.org/v4.0.0/images/creating-a-custom-theme.png" medium="image"/><content:encoded><![CDATA[<img src="https://static.ghost.org/v4.0.0/images/creating-a-custom-theme.png" alt="Building your audience with subscriber signups"/><p>What sets Ghost apart from other products is that you can publish content and grow your audience using the same platform. Rather than just endlessly posting and hoping someone is listening, you can track real signups against your work and have them subscribe to be notified of future posts. The feature that makes all this possible is called <em>Portal</em>.</p><p>Portal is an embedded interface for your audience to sign up to your site. It works on every Ghost site, with every theme, and for any type of publisher. </p><p>You can customize the design, content and settings of Portal to suit your site, whether you just want people to sign up to your newsletter ‚Äî or you're running a full premium publication with user sign-ins and private content.</p><figure class="kg-card kg-image-card kg-width-wide"><img src="https://static.ghost.org/v4.0.0/images/portalsettings.png" class="kg-image" alt="Building your audience with subscriber signups" loading="lazy" width="2924" height="1810"/></figure><p>Once people sign up to your site, they'll receive an email confirmation with a link to click. The link acts as an automatic sign-in, so subscribers will be automatically signed-in to your site when they click on it. There are a couple of interesting angles to this:</p><p>Because subscribers are automatically able to sign in and out of your site as registered members: You can (optionally) restrict access to posts and pages depending on whether people are signed-in or not. So if you want to publish some posts for free, but keep some really great stuff for members-only, this can be a great draw to encourage people to sign up!</p><p>Ghost members sign in using email authentication links, so there are no passwords for people to set or forget. You can turn any list of email subscribers into a database of registered members who can sign in to your site. Like magic.</p><p>Portal makes all of this possible, and it appears by default as a floating button in the bottom-right corner of your site. When people are logged out, clicking it will open a sign-up/sign-in window. When members are logged in, clicking the Portal button will open the account menu where they can edit their name, email, and subscription settings.</p><p>The floating Portal button is completely optional. If you prefer, you can add manual links to your content, navigation, or theme to trigger it instead.</p><p>Like this! <a href="#/portal">Sign up here</a></p><hr><p>As you start to grow your registered audience, you'll be able to get a sense of who you're publishing <em>for</em> and where those people are coming <em>from</em>. Best of all: You'll have a straightforward, reliable way to connect with people who enjoy your work.</p><p>Social networks go in and out of fashion all the time. Email addresses are timeless.</p><p>Growing your audience is valuable no matter what type of site you run, but if your content <em>is</em> your business, then you might also be interested in <a href="https://iron.fordeer.agency/sell/">setting up premium subscriptions</a>.</p></hr>]]></content:encoded></item><item><title><![CDATA[Selling premium memberships with recurring revenue]]></title><description><![CDATA[For creators and aspiring entrepreneurs looking to generate a sustainable
recurring revenue stream from their creative work, Ghost has built-in payments
allowing you to create a subscription commerce business.

Connect your Stripe [https://stripe.com] account to Ghost, and you'll be able to
quickly and easily create monthly and yearly premium plans for members to
subscribe to, as well as complimentary plans for friends and family.

Ghost takes 0% payment fees, so everything you make is yours to ]]></description><link>http://localhost:8000/sell/</link><guid isPermaLink="false">Ghost__Post__612df6616c623f9319ddfd26</guid><category><![CDATA[Getting Started]]></category><dc:creator><![CDATA[Ghost]]></dc:creator><pubDate>Tue, 31 Aug 2021 09:29:06 GMT</pubDate><media:content url="https://static.ghost.org/v4.0.0/images/organizing-your-content.png" medium="image"/><content:encoded><![CDATA[<img src="https://static.ghost.org/v4.0.0/images/organizing-your-content.png" alt="Selling premium memberships with recurring revenue"/><p>For creators and aspiring entrepreneurs looking to generate a sustainable recurring revenue stream from their creative work, Ghost has built-in payments allowing you to create a subscription commerce business.</p><p>Connect your <a href="https://stripe.com">Stripe</a> account to Ghost, and you'll be able to quickly and easily create monthly and yearly premium plans for members to subscribe to, as well as complimentary plans for friends and family.</p><p>Ghost takes <strong>0% payment fees</strong>, so everything you make is yours to keep!</p><p>Using subscriptions, you can build an independent media business like <a href="https://stratechery.com">Stratechery</a>, <a href="https://www.theinformation.com">The Information</a>, or <a href="https://thebrowser.com">The Browser</a>.</p><p>The creator economy is just getting started, and Ghost allows you to build something based on technology that you own and control.</p><figure class="kg-card kg-image-card kg-card-hascaption"><a href="https://thebrowser.com"><img src="https://static.ghost.org/v4.0.0/images/thebrowser.jpg" class="kg-image" alt="Selling premium memberships with recurring revenue" loading="lazy" width="1600" height="2000"/></a><figcaption>The Browser has over 10,000 paying subscribers</figcaption></figure><p>Most successful subscription businesses publish a mix of free and paid posts to attract a new audience, and upsell the most loyal members to a premium offering. You can also mix different access levels within the same post, showing a free preview to logged out members and then, right when you're ready for a cliffhanger, that's a good time to...</p>]]></content:encoded></item><item><title><![CDATA[How to grow your business around an audience]]></title><description><![CDATA[A guide to collaborating with other staff users to publish, and some resources to help you with the next steps of growing your business]]></description><link>http://localhost:8000/grow/</link><guid isPermaLink="false">Ghost__Post__612df6616c623f9319ddfd24</guid><category><![CDATA[Getting Started]]></category><dc:creator><![CDATA[Ghost]]></dc:creator><pubDate>Tue, 31 Aug 2021 09:29:05 GMT</pubDate><media:content url="https://static.ghost.org/v4.0.0/images/admin-settings.png" medium="image"/><content:encoded><![CDATA[<img src="https://static.ghost.org/v4.0.0/images/admin-settings.png" alt="How to grow your business around an audience"/><p>As you grow, you'll probably want to start inviting team members and collaborators to your site. Ghost has a number of different user roles for your team:</p><p><strong>Contributors</strong><br>This is the base user level in Ghost. Contributors can create and edit their own draft posts, but they are unable to edit drafts of others or publish posts. Contributors are <strong>untrusted</strong> users with the most basic access to your publication.</br></p><p><strong>Authors</strong><br>Authors are the 2nd user level in Ghost. Authors can write, edit and publish their own posts. Authors are <strong>trusted</strong> users. If you don't trust users to be allowed to publish their own posts, they should be set as Contributors.</br></p><p><strong>Editors</strong><br>Editors are the 3rd user level in Ghost. Editors can do everything that an Author can do, but they can also edit and publish the posts of others - as well as their own. Editors can also invite new Contributors &amp; Authors to the site.</br></p><p><strong>Administrators</strong><br>The top user level in Ghost is Administrator. Again, administrators can do everything that Authors and Editors can do, but they can also edit all site settings and data, not just content. Additionally, administrators have full access to invite, manage or remove any other user of the site.<br><br><strong>The Owner</strong><br>There is only ever one owner of a Ghost site. The owner is a special user which has all the same permissions as an Administrator, but with two exceptions: The Owner can never be deleted. And in some circumstances the owner will have access to additional special settings if applicable. For example: billing details, if using <a href="https://ghost.org/pricing/"><strong>Ghost(Pro)</strong></a>.</br></br></br></br></p><blockquote><em>Ask all of your users to fill out their user profiles, including bio and social links. These will populate rich structured data for posts and generally create more opportunities for themes to fully populate their design.</em></blockquote><hr><p>If you're looking for insights, tips and reference materials to expand your content business, here's 5 top resources to get you started:</p><ul><li><a href="https://ghost.org/blog/how-to-create-a-newsletter/"><strong>How to create a premium newsletter (+ some case studies)</strong></a><strong> </strong> <br>Learn how others run successful paid email newsletter products</br></li><li><strong><a href="https://ghost.org/blog/membership-sites/">The ultimate guide to membership websites for creators</a></strong><br>Tips to help you build, launch and grow your new membership business</br></li><li><strong><a href="https://newsletterguide.org/">The Newsletter Guide</a></strong><br>A 201 guide for taking your newsletters to the next level</br></li><li><a href="https://ghost.org/blog/find-your-niche-creator-economy/"><strong>The proven way to find your niche, explained</strong></a><br>Find the overlap and find a monetizable niche that gets noticed</br></li><li><strong><a href="https://ghost.org/blog/newsletter-referral-programs/">Should you launch a referral program? </a></strong><br>Strategies for building a sustainable referral growth machine</br></li></ul></hr>]]></content:encoded></item></channel></rss>